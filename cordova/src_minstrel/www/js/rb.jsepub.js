//
//            _           _            _ 
//           (_)         | |          | |
//  _ __ ___  _ _ __  ___| |_ _ __ ___| |
// | '_ ` _ \| | '_ \/ __| __| '__/ _ \ |
// | | | | | | | | | \__ \ |_| | |  __/ |
// |_| |_| |_|_|_| |_|___/\__|_|  \___|_|
//
// Author:      Alberto Pettarin (www.albertopettarin.it)
// Copyright:   Copyright 2013-2015, ReadBeyond Srl (www.readbeyond.it)
// License:     MIT
// Email:       minstrel@readbeyond.it
// Web:         http://www.readbeyond.it/minstrel/
// Status:      Production
//

/**

@overview

## Introduction 

This JS file provides a data model for a EPUB 2/3 publication,
and a corresponding self-contained parser.

You can build the {@link RB.Format.EPUB.EPUB|EPUB object}
in two ways:

- by parsing the contents of a given directory
where you previously unzipped the EPUB, or
- by restoring it from a JSON object,
suitably obtained from a `JSON.parse(str)` call.
For example, `str` might be a string,
retrieved from some sort of storage,
which was generated by `JSON.stringify(epub_obj)`.

Example:

    // parse path/to/my/ebook/ directory and create the EPUB object
    var ebook = new RB.Format.EPUB.EPUB("path/to/my/ebook/");
    
    // get the TOC:
    var toc = ebook.getTOC();
    // do something with toc
    ...

    // you can stringify the ebook and store it somewhere:
    var ebook_s = JSON.stringify(ebook);
    ...

    // later, you can get the stored string into ebook_r
    // and restore the EPUB object:
    var obj_r = JSON.parse(ebook_r);
    var restored = new RB.Format.EPUB.EPUB(obj_r);
    // now you can get the spine from the restored object:
    var spine = restored.getSpine();
    // do something with spine
    ...

Currently, the EPUB object supports
_almost_ all the (hopefully, _all_ the _useful_)
elements/properties in:

- EPUB container,
- OPF package,
- OPF metadata,
- OPF manifest,
- OPF spine,
- OPF guide, and
- NCX or XHTML TOC.

By design, the EPUB object
does not provide APIs to support navigation or rendering
(e.g., `goToChapter(i)` or `displayTOC()`).
In fact, the EPUB object is simply meant to be
a convenient data structure for EPUB information,
offering sane, easy-to-use APIs to retrieve them.


## Extra features

The associated parser can build some extra structures,
which provides "pre-processed" structures
used in Minstrel app:

- a {@link RB.Format.ROD.ROD|Reading Order Data (ROD)} object,
which can be thought as an augmented spine,
- a {@link RB.Format.Playlist.Playlist|Playlist} object,
containing all the text and audio assets
associated via EPUB 3 Media Overlays, and
- parsing EPUB 3 Media Overlays (SMIL) files
with "linear" structure (see below).

When creating the EPUB object by parsing
the contents of a given directory,
there are a couple of parameters
that can be specified to adjust
the depth/leniency of the parser,
see {@link RB.Format.EPUB.EPUB|here}.


## Current limitations

- Some EPUB 3 elements/attributes are currently not supported/parsed (e.g., `collection`)
- The EPUB 2 `<guide>` is parsed looking only for `cover`, `text`, and `toc`
- To be considered "valid", SMIL files must have a "linear" structure
(basically, just a `<seq>` of `<par>`s), and each SMIL file must reference
exactly one text src and one audio src
- From a code perspective, there is no data hiding/protection mechanisms
(i.e., there is no safety net, be careful!)


## TODO list

- AMD/Module support
- Factor repeated code (e.g., `loadFromJSON()`)
- Some code might be replaced by `underscore.js` functions
- Complete EPUB 3 parser (e.g., `collection`)
- Split EPUB data structure and EPUB parser




@author Alberto Pettarin (alberto@readbeyond.it)
@copyright 2013-2015, {@link http://www.readbeyond.it|ReadBeyond}, Padova, Italy
@license MIT 
@version 3.0.1

*/

// be strict, be safe
'use strict';

/** @namespace RB */
var RB = RB || {};

/** @namespace RB.Format */
RB.Format = RB.Format || {};

/** @namespace RB.Format.OPF */
RB.Format.OPF = RB.Format.OPF || {};

/**
    @classdesc A single metadatum. Roughly equivalent to one or more elements in the OPF `<metadata>`. Multiple elements in the OPF `<metadata>` might be "merged" into a `RB.Format.OPF.Metadatum`, e.g. by "dictionarizing" `refines` elements.
    @example
    var m = new RB.Format.OPF.Metadatum("mTitle", RB.Format.OPF.Metadatum.NameEnum.DC_TITLE, "My awesome book", null);
    @class
    @param {string} id - The `id` attribute of the corresponding element in the OPF `<metadata>`. It might be `null`.
    @param {RB.Format.OPF.Metadatum.NameEnum} name - The (tag) name of the corresponding element in the OPF `<metadata>`. Never `null`.
    @param {string} value - The value of the metadatum.
    @param {object} attributes - A dictionary of additional attributes. The semantics depend on the actual metadatum. It might be `null`.
*/
RB.Format.OPF.Metadatum = RB.Format.OPF.Metadatum || function(id, name, value, attributes) {
    this.id         = id;
    this.name       = name;
    this.value      = value;
    this.attributes = attributes;
};
/**
    Enumeration of supported metadatum names. 
    @todo Use `Object.freeze` to freeze the enum. (Currently not in place, due to a JSDoc bug.)
    @readonly
    @enum {string}
*/
RB.Format.OPF.Metadatum.NameEnum = {
    /** dc:contributor */
    DC_CONTRIBUTOR:                 "dc:contributor",

    /** dc:coverage */
    DC_COVERAGE:                    "dc:coverage",

    /** dc:creator */
    DC_CREATOR:                     "dc:creator",

    /** dc:date */
    DC_DATE:                        "dc:date",

    /** dc:description */
    DC_DESCRIPTION:                 "dc:description",

    /** dc:format */
    DC_FORMAT:                      "dc:format",

    /** dc:identifier */
    DC_IDENTIFIER:                  "dc:identifier",

    /** dc:language */
    DC_LANGUAGE:                    "dc:language",

    /** dc:publisher */
    DC_PUBLISHER:                   "dc:publisher",

    /** dc:relation */
    DC_RELATION:                    "dc:relation",

    /** dc:rights */
    DC_RIGHTS:                      "dc:rights",

    /** dc:source */
    DC_SOURCE:                      "dc:source",

    /** dc:subject */
    DC_SUBJECT:                     "dc:subject",

    /** dc:title */
    DC_TITLE:                       "dc:title",

    /** dc:type */
    DC_TYPE:                        "dc:type",

    /** dcterms:modified */
    DCTERMS_MODIFIED:               "dcterms:modified",

    /** epub:unique-identifier (custom, represents the `unique-identifier` attribute of `<package>`) */
    EPUB_UNIQUE_IDENTIFIER:         "epub:unique-identifier",

    /** epub:version (custom, represents the `version` attribute of `<package>`) */
    EPUB_VERSION:                   "epub:version",

    /** epub2:cover (custom, represents the path inside the EPUB container of the cover image) */
    EPUB2_COVER:                    "epub2:cover",

    /** epub2:guide:cover (custom, represents the path inside the EPUB container of the `cover` item of the `<guide>`) */
    EPUB2_GUIDE_COVER:              "epub2:guide:cover",

    /** epub2:guide:text (custom, represents the path inside the EPUB container of the `text` item of the `<guide>`) */
    EPUB2_GUIDE_TEXT:               "epub2:guide:text",

    /** epub2:guide:toc (custom, represents the path inside the EPUB container of the `toc` item of the `<guide>`) */
    EPUB2_GUIDE_TOC:                "epub2:guide:toc",

    /** epub3:cover (custom, represents the path inside the EPUB container of the cover image) */
    EPUB3_COVER:                    "epub3:cover",

    /** media:active-class */
    MEDIA_ACTIVE_CLASS:             "media:active-class",

    /** media:duration */
    MEDIA_DURATION:                 "media:duration",

    /** media:duration:total (custom, represents the (total) duration of the publication MO) */
    MEDIA_DURATION_TOTAL:           "media:duration:total",

    /** media:narrator */
    MEDIA_NARRATOR:                 "media:narrator",

    /** media:paused-class */
    MEDIA_PAUSED_CLASS:             "media:paused-class",

    /** media:playback-active-class */
    MEDIA_PLAYBACK_ACTIVE_CLASS:    "media:playback-active-class",

    /** nonlinear:crossable (custom) */
    NONLINEAR_CROSSABLE:            "nonlinear:crossable",

    /** parallel:language (custom) */
    PARALLEL_LANGUAGE:              "parallel:language",

    /** parallel:link-class (custom) */
    PARALLEL_LINK_CLASS:            "parallel:link-class",

    /** parallel:text-class (custom) */
    PARALLEL_TEXT_CLASS:            "parallel:text-class",

    /** rendition:flow */
    RENDITION_FLOW:                 "rendition:flow",

    /** rendition:layout */
    RENDITION_LAYOUT:               "rendition:layout",

    /** rendition:orientation */
    RENDITION_ORIENTATION:          "rendition:orientation",

    /** rendition:spread */
    RENDITION_SPREAD:               "rendition:spread",
    
    /** rendition:viewport */
    RENDITION_VIEWPORT:             "rendition:viewport",

    /** rendition:viewport:global (custom, represents the global viewport of the publication) */
    RENDITION_VIEWPORT_GLOBAL:      "rendition:viewport:global"
};
/**
    Populate the instance variables by parsing the given object.
    @param {object} obj - A dictionary (i.e., { key1: value1, key2: value2, ... }). 
*/
RB.Format.OPF.Metadatum.prototype.loadFromObject = function(obj) {
    var instance_vars = [ "id", "name", "value", "attributes" ];
    if (obj) {
        for (var i = 0; i < instance_vars.length; i++) {
            var key = instance_vars[i];
            if (key in obj) {
                this[key] = obj[key];
            }
        }
    }
};
/**
    Append the given attributes to the instance variable attributes.
    @example
    var m = new RB.Format.OPF.Metadatum("mAuthor", RB.Format.OPF.Metadatum.NameEnum.DC_CREATOR, "Foo Bar", null);
    m.appendAttributes( {"role": "aut", "file-as": "Bar, Foo"} );
    @param {object} attributes - A dictionary (i.e., { key1: value1, key2: value2, ... }) of additional attributes.
*/
RB.Format.OPF.Metadatum.prototype.appendAttributes = function(attributes) {
    if (attributes) {
        if (! this.attributes) {
            this.attributes = {};
        }
        var keys = Object.keys(attributes);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            this.attributes[key] = attributes[key];
        }
    }
};

/**
    @classdesc A data structure to store metadata.
    It is roughly equivalent to the OPF `<metadata>` element.
    Internally, metadata are kept in a dictionary, indexed by metadatum name,
    and whose values are lists of {@link RB.Format.OPF.Metadatum} objects.
    This class provides specialized accessor methods,
    for example you can query a metadatum by its id or
    get all the metadata with the same name
    (e.g., `RB.Format.OPF.Metadatum.NameEnum.DC_SUBJECT`).
    @example
    var meta = new RB.Format.OPF.Metadata();
    @class
*/
RB.Format.OPF.Metadata = RB.Format.OPF.Metadata || function() {
    this.metadata       = {};
    this.metadata_by_id = {};
};
/**
    Add the given metadatum to this collection.
    @example
    // add title metadatum to a newly created Metadata object
    var m = new RB.Format.OPF.Metadatum("mTitle", RB.Format.OPF.Metadatum.NameEnum.DC_TITLE, "My awesome book", null);
    var meta = new RB.Format.OPF.Metadata();
    meta.addMetadatum(m)
    @param {RB.Format.OPF.Metadatum} metadatum - The metadatum to be added.
*/
RB.Format.OPF.Metadata.prototype.addMetadatum = function(metadatum) {
    if (!(metadatum.name in this.metadata)) {
        this.metadata[metadatum.name] = [];
    }
    this.metadata[metadatum.name].push(metadatum);
    if (metadatum.id) {
        this.metadata_by_id[metadatum.id] = metadatum;
    }
};
/**
    Query metadata with a given name.
    @example
    // meta is a RB.Format.OPF.Metadata object
    var arr = meta.getMetadataByName(RB.Format.OPF.Metadatum.NameEnum.DC_CREATOR);
    // arr contains all the dc:creator metadata parsed out of the EPUB
    @param  {RB.Format.OPF.Metadatum.NameEnum} name - The desired metadata name.
    @return {object} x- An array of {@link RB.Format.OPF.Metadatum} objects matching `name`. It might be `null` if not found.
*/
RB.Format.OPF.Metadata.prototype.getMetadataByName = function(name) {
    return this.metadata[name];
};
/**
    Query a single metadatum by its id.
    @example
    // meta is a RB.Format.OPF.Metadata object
    var m = meta.getMetadatumById("mTitle");
    // m contains the metadatum with id "mTitle"
    @param  {string} id - The desired metadatum id.
    @return {RB.Format.OPF.Metadatum} x- The {@link RB.Format.OPF.Metadatum} matching `id`. It might be `null` if not found.
*/
RB.Format.OPF.Metadata.prototype.getMetadatumById = function(id) {
    return this.metadata_by_id[id];
};
/**
    Query metadata values with a given name.
    @example
    // meta is a RB.Format.OPF.Metadata object
    // suppose the EPUB has two dc:creator elements:
    // one for author Foo Bar, the other for translator Baz Baz
    var v1 = meta.getMetadatumValue(RB.Format.OPF.Metadatum.NameEnum.DC_CREATOR, true, true);
    //  v1 = "Foo Bar"
    var v2 = meta.getMetadatumValue(RB.Format.OPF.Metadatum.NameEnum.DC_CREATOR, false, true);
    //  v2 = "Foo Bar; Baz Baz"
    var v3 = meta.getMetadatumValue(RB.Format.OPF.Metadatum.NameEnum.DC_CREATOR, false, false);
    //  v3 = ["Foo Bar", "Baz Baz"]
    @param  {RB.Format.OPF.Metadatum.NameEnum} name - The desired metadata name.
    @param  {boolean} only_first - If `true`, returns only the value of the first {@link RB.Format.OPF.Metadatum} with name `name`. If `false`, returns the values of all matching metadata objects.
    @param  {boolean} as_string - If `true`, concatenates the matching metadata values into a single string. If `false`, returns them as an arrayof strings.
    @return {object} x- A `string` or an array of `string`s, containing the matching metadata values. It might be `null` if not found.
*/
RB.Format.OPF.Metadata.prototype.getMetadatumValue = function(name, only_first, as_string) {
    var arr = this.metadata[name];
    if ((arr) && (arr.length > 0)) {
        if (only_first) {
            return arr[0].value;
        }
        if (as_string) {
            var r = "";
            for (var i = 0; i < arr.length - 1; i++) {
                r += arr[i].value + "; ";
            }
            r += arr[arr.length - 1].value;
            return r;
        }
        var r = [];
        for (var i = 0; i < arr.length; i++) {
            r.push(arr[i].value);
        }
        return r;
    }
    return null;
};
/**
    Populate the instance variables by parsing the given object.
    @param {object} obj - A dictionary (i.e., { key1: value1, key2: value2, ... }). 
*/
RB.Format.OPF.Metadata.prototype.loadFromObject = function(obj) {
    if ((obj) && (obj.metadata)) {
        obj = obj.metadata;
        var keys = Object.keys(obj);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var items = obj[key];
            for (var j = 0; j < items.length; j++) {
                var n = new RB.Format.OPF.Metadatum();
                n.loadFromObject(items[j]);
                this.addMetadatum(n);
            }
        }
    }
};

/**
    @classdesc A single manifest item. Roughly equivalent to the OPF `<manifest><item>` element.
    @example
    var mi = new RB.Format.OPF.ManifestItem("p001", "OEBPS/Text/p001.xhtml", "application/xhtml+xml", { "media-overlay": "s001", "properties": "scripted" }, null);
    @class
    @param {string} id - The `id` attribute of the corresponding `<item>` element in the OPF `<manifest>`. Never `null`.
    @param {string} href - The path, w.r.t. the EPUB container root, of the referenced asset (e.g., `OEBPS/Text/p001.xhtml`). Never `null`.
    @param {string} media_type - The `media-type` attribute of the corresponding `<item>` element in the OPF `<manifest>`. Never `null`.
    @param {object} info - A dictionary containing additional information about the manifest item. Supported keys are:

- `fallback`: (string) the `fallback` attribute of the corresponding `<item>` element in the OPF `<manifest>`,
- `media-overlay`: (string) the `media-overlay` attribute of the corresponding `<item>` element in the OPF `<manifest>`,
- `properties`: (string) the `properties` attribute of the corresponding `<item>` element in the OPF `<manifest>`.
    
    @param {object} attributes - A dictionary of additional attributes. The semantics depend on the actual item. It might be `null`.
*/
RB.Format.OPF.ManifestItem = RB.Format.OPF.ManifestItem || function(id, href, media_type, info, attributes) {
    this["id"]            = id;
    this["href"]          = href;
    this["media-type"]    = media_type;
    this["fallback"]      = null;
    this["media-overlay"] = null;
    this["properties"]    = null;
    if (info) {
        var info_keys = [ "fallback", "media-overlay", "properties" ];
        for (var i = 0; i < info_keys.length; i++) {
            var key = info_keys[i];
            if (key in info) {
                this[key] = info[key];
            }
        }
    }
    this["attributes"]    = attributes;
};
/**
    Append the given attributes to the instance variable attributes.
    @example
    var mi = new RB.Format.OPF.ManifestItem("p001", "OEBPS/Text/p001.xhtml", "application/xhtml+xml");
    mi.appendAttributes( {"myproperty": "myvalue", "anotherproperty": "anothervalue"} );
    @param {object} attributes - A dictionary (i.e., { key1: value1, key2: value2, ... }) of additional attributes.
*/
RB.Format.OPF.ManifestItem.prototype.appendAttributes = function(attributes) {
    if (attributes) {
        if (! this.attributes) {
            this.attributes = {};
        }
        var keys = Object.keys(attributes);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            this.attributes[key] = attributes[key];
        }
    }
};
/**
    Populate the instance variables by parsing the given object.
    @param {object} obj - A dictionary (i.e., { key1: value1, key2: value2, ... }). 
*/
RB.Format.OPF.ManifestItem.prototype.loadFromObject = function(obj) {
    var instance_vars = ["id", "href", "media-type", "fallback", "media-overlay", "properties", "attributes" ];
    if (obj) {
        for (var i = 0; i < instance_vars.length; i++) {
            var key = instance_vars[i];
            if (key in obj) {
                this[key] = obj[key];
            }
        }
    }
};

/**
    @classdesc A data structure to store manifest items.
    It is roughly equivalent to the OPF `<manifest>` element.
    This class provides specialized accessor methods,
    for example you can query a manifest item by its id or href.
    @example
    var manifest = new RB.Format.OPF.Manifest();
    @class
*/
RB.Format.OPF.Manifest = RB.Format.OPF.Manifest || function() {
    this.manifest         = [];
    this.manifest_by_id   = {};
    this.manifest_by_href = {};
};
/**
    Add the given manifest item to this collection.
    @example
    var manifest = new RB.Format.OPF.Manifest();
    var mi = new RB.Format.OPF.ManifestItem("p001", "OEBPS/Text/p001.xhtml", "application/xhtml+xml");
    manifest.addManifestItem(mi);
    @param {RB.Format.OPF.ManifestItem} manifestItem - The manifest item to be added.
*/
RB.Format.OPF.Manifest.prototype.addManifestItem = function(manifestItem) {
    this.manifest.push(manifestItem);
    if (manifestItem.id) {
        this.manifest_by_id[manifestItem.id] = manifestItem;
    }
    if (manifestItem.href) {
        this.manifest_by_href[manifestItem.href] = manifestItem;
    }
};
/**
    Query a single manifest item by its id.
    @example
    // manifest is a RB.Format.OPF.Manifest object
    var mi = manifest.getManifestItemById("p001");
    // mi now contains the manifest item with id "p001"
    @param  {string} id - The desired manifest item id.
    @return {RB.Format.OPF.ManifestItem} x- The {@link RB.Format.OPF.ManifestItem} matching `id`. It might be `null` if not found.
*/
RB.Format.OPF.Manifest.prototype.getManifestItemById = function(id) {
    return this.manifest_by_id[id];
};
/**
    Query a single manifest item by its href.
    @example
    // manifest is a RB.Format.OPF.Manifest object
    var mi = manifest.getManifestItemByHref("OEBPS/Text/p001.xhtml");
    // mi now contains the manifest item located at OEBPS/Text/p001.xhtml inside the EPUB container
    @param  {string} href - The desired manifest item href, which is the path, w.r.t. the EPUB container root, of the referenced asset (e.g., `OEBPS/Text/p001.xhtml`). Never `null`.
    @return {RB.Format.OPF.ManifestItem} x- The {@link RB.Format.OPF.ManifestItem} matching `href`. It might be `null` if not found.
*/
RB.Format.OPF.Manifest.prototype.getManifestItemByHref = function(href) {
    return this.manifest_by_href[href];
};
/**
    Populate the instance variables by parsing the given object.
    @param {object} obj - A dictionary (i.e., { key1: value1, key2: value2, ... }). 
*/
RB.Format.OPF.Manifest.prototype.loadFromObject = function(obj) {
    if ((obj) && (obj.manifest)) {
        obj = obj.manifest;
        for (var i = 0; i < obj.length; i++) {
            var n = new RB.Format.OPF.ManifestItem();
            n.loadFromObject(obj[i]);
            this.addManifestItem(n);
        }
    }
};

/**
    @classdesc A single spine item. Roughly equivalent to the OPF `<spine><itemref>` element.
    @example
    // si1 is equivalent to `<itemref idref="p001"/>` 
    var si1 = new RB.Format.OPF.SpineItem("p001", null, null);
    // si2 is equivalent to `<itemref idref="p002" linear="yes"/>`
    var si2 = new RB.Format.OPF.SpineItem("p002", "yes", null);
    @class
    @param {string} idref - The `id`, w.r.t. the manifest, of the referenced asset (e.g., `p001`). Never `null`.
    @param {string} linear - The `linear` attribute of the corresponding `<itemref>` element in the OPF `<manifest>`. It might be `null` (i.e., not present), `yes`, or `no`.
    @param {string} properties - The value of the `properties` attribute. It might be `null` (i.e., not present).
*/
RB.Format.OPF.SpineItem = RB.Format.OPF.SpineItem || function(idref, linear, properties) {
    this.idref      = idref;
    this.linear     = linear;
    this.properties = properties;
};
/**
    Allowed values for the `properties` attribute.
    @todo Use Object.freeze to freeze the enum. (Currently not in place, due to a JSDoc bug.)
    @readonly
    @enum {string}
*/
RB.Format.OPF.SpineItem.PropertiesEnum = {
    /** rendition:align-x-center */
    RENDITION_ALIGN_X_CENTER:           "rendition:align-x-center",
    
    /** rendition:flow-auto */
    RENDITION_FLOW_AUTO:                "rendition:flow-auto",
    
    /** rendition:flow-paginated */
    RENDITION_FLOW_PAGINATED:           "rendition:flow-paginated",
    
    /** rendition:flow-scrolled-continuous */
    RENDITION_FLOW_SCROLLED_CONTINUOUS: "rendition:flow-scrolled-continuous",
    
    /** rendition:flow-scrolled-doc */
    RENDITION_FLOW_SCROLLED_DOC:        "rendition:flow-scrolled-doc",
    
    /** rendition:layout-pre-paginated */
    RENDITION_LAYOUT_PRE_PAGINATED:     "rendition:layout-pre-paginated",
    
    /** rendition:layout-reflowable */
    RENDITION_LAYOUT_REFLOWABLE:        "rendition:layout-reflowable",
    
    /** rendition:orientation-auto */
    RENDITION_ORIENTATION_AUTO:         "rendition:orientation-auto",
    
    /** rendition:orientation-landscape */
    RENDITION_ORIENTATION_LANDSCAPE:    "rendition:orientation-landscape",
    
    /** rendition:orientation-portrait */
    RENDITION_ORIENTATION_PORTRAIT:     "rendition:orientation-portrait",
    
    /** rendition:page-spread-center */
    RENDITION_PAGE_SPREAD_CENTER:       "rendition:page-spread-center",
    
    /** page-spread-left */
    PAGE_SPREAD_LEFT:                   "page-spread-left",
    
    /** page-spread-right */
    PAGE_SPREAD_RIGHT:                  "page-spread-right",
    
    /** rendition:spread-auto */
    RENDITION_SPREAD_AUTO:              "rendition:spread-auto",
    
    /** rendition:spread-both */
    RENDITION_SPREAD_BOTH:              "rendition:spread-both",
    
    /** rendition:spread-landscape */
    RENDITION_SPREAD_LANDSCAPE:         "rendition:spread-landscape",
    
    /** rendition:spread-none */
    RENDITION_SPREAD_NONE:              "rendition:spread-none",
    
    /** rendition:spread-portrait */
    RENDITION_SPREAD_PORTRAIT:          "rendition:spread-portrait"
};
/**
    Populate the instance variables by parsing the given object.
    @param {object} obj - A dictionary (i.e., { key1: value1, key2: value2, ... }). 
*/
RB.Format.OPF.SpineItem.prototype.loadFromObject = function(obj) {
    var instance_vars = [ "idref", "linear", "properties" ];
    if (obj) {
        for (var i = 0; i < instance_vars.length; i++) {
            var key = instance_vars[i];
            if (key in obj) {
                this[key] = obj[key];
            }
        }
    }
};

/**
    @classdesc A data structure to store the spine (linear reading order).
    It is roughly equivalent to the OPF `<spine>` element.
    This class is essentially a wrapper for an array of {@link RB.Format.OPF.SpineItem} objects.
    It also builds a second array, `spine_linear`,
    containing only {@link RB.Format.OPF.SpineItem} objects
    with the `linear` attribute set to yes (or not specified).
    @example
    var spine = new RB.Format.OPF.Spine();
    @class
*/
RB.Format.OPF.Spine = RB.Format.OPF.Spine || function() {
    // `toc` attribute of `<spine>`
    this["toc"]                        = null;
    
    // `page-progression-direction` attribute of `<spine>`
    this["page-progression-direction"] = null;
    
    // actual spine
    this["spine"]                       = [];

    // only those items with linear="yes" (implicitly or explicitly)
    this["spine_linear"]                = [];
};
/**
    Allowed values for the `page-progression-direction` attribute.
    @todo Use Object.freeze to freeze the enum. (Currently not in place, due to a JSDoc bug.)
    @readonly
    @enum {string}
*/
RB.Format.OPF.Spine.PageProgressionDirectionEnum = {
    /** ltr */
    LTR:        "ltr",

    /** rtl */
    RTL:        "rtl",

    /** default */
    DEFAULT:    "default"
};
/**
    Add the given spine item to this collection.
    @example
    var s = new RB.Format.OPF.Spine();
    var si1 = new RB.Format.OPF.SpineItem("p001", "yes", null);
    var si2 = new RB.Format.OPF.SpineItem("p002", "no", null);
    s.addSpineItem(si1);
    s.addSpineItem(si2);
    @param {RB.Format.OPF.SpineItem} spineItem - The spine item to be added.
*/
RB.Format.OPF.Spine.prototype.addSpineItem = function(spineItem) {
    this.spine.push(spineItem);
    if (spineItem.linear !== "no") {
        this.spine_linear.push(spineItem);
    }
};
/**
    Populate the instance variables by parsing the given object.
    @param {object} obj - A dictionary (i.e., { key1: value1, key2: value2, ... }). 
*/
RB.Format.OPF.Spine.prototype.loadFromObject = function(obj) {
    if (obj) {
        if (obj["toc"]) {
            this["toc"] = obj["toc"];
        }
        if (obj["page-progression-direction"]) {
            this["page-progression-direction"] = obj["page-progression-direction"];
        }
        if (obj["spine"]) {
            obj = obj["spine"];
            for (var i = 0; i < obj.length; i++) {
                var n = new RB.Format.OPF.SpineItem();
                n.loadFromObject(obj[i]);
                this.addSpineItem(n);
            }
        }
    }
};

/** @namespace RB.Format.TOC */
RB.Format.TOC = RB.Format.TOC || {};

/**
    @classdesc A single TOC node.
    @example
    // The following lines create the nodes of this structure:
    // Chapter 1
    // Chapter 2
    //   Section A
    //   Section B
    //   Section C
    var ti1  = new RB.Format.TOC.TOCItem("OEBPS/Text/p001.xhtml", null, "Chapter 1", null);
    var ti2a = new RB.Format.TOC.TOCItem("OEBPS/Text/p002.xhtml", "sA", "Section A", null);
    var ti2b = new RB.Format.TOC.TOCItem("OEBPS/Text/p002.xhtml", "sB", "Section B", null);
    var ti2c = new RB.Format.TOC.TOCItem("OEBPS/Text/p002.xhtml", "sC", "Section C", null);
    var ti2  = new RB.Format.TOC.TOCItem("OEBPS/Text/p002.xhtml", null, "Chapter 2", [ ti2a, ti2b, ti2c ]);
    @class
    @param {string} href - The manifest item href, which is the path, w.r.t. the EPUB container root, of the referenced asset (e.g., `OEBPS/Text/p001.xhtml`). It might be `null` (e.g., if this node is just a "label").
    @param {string} anchor - The anchor inside the referenced asset, without the leading "#" (e.g., `bar` in `foo.xhtml#bar`). It might be `null`.
    @param {string} label - The text label associated with this TOC node. Never `null`.
    @param {object} children - An array of {@link RB.Format.TOC.TOCItem} objects, representing the children nodes. It might be `null`.
*/
RB.Format.TOC.TOCItem = RB.Format.TOC.TOCItem || function(href, anchor, label, children) {
    this.href     = href;
    this.anchor   = anchor;
    this.label    = label;
    this.children = children;
};
/**
    Populate the instance variables by parsing the given object.
    @param {object} obj - A dictionary (i.e., { key1: value1, key2: value2, ... }). 
*/
RB.Format.TOC.TOCItem.prototype.loadFromObject = function(obj) {
    var instance_vars = [ "href", "anchor", "label", "children" ];
    if (obj) {
        for (var i = 0; i < instance_vars.length; i++) {
            var key = instance_vars[i];
            if (key in obj) {
                if ((key === "children") && (obj[key])) {
                    var children = obj[key];
                    var nc = [];
                    for (var j = 0; j < children.length; j++) {
                        var n = new RB.Format.TOC.TOCItem();
                        n.loadFromObject(children[j]);
                        nc.push(n);
                    }
                    this[key] = nc;
                } else {
                    this[key] = obj[key];
                }
            }
        }
    }
};

/**
    @classdesc A data structure to store a TOC (table of contents) tree.
    It abstracts both the EPUB 2 NCX TOC and the EPUB 3 XHTML nav TOC.
    Note that the TOC must be created bottom-up,
    since this class just stores a list of level-0 TOC nodes.
    @example
    var toc = new RB.Format.TOC.TOC();
    @class
*/
RB.Format.TOC.TOC = RB.Format.TOC.TOC || function() {
    this.toc                    = [];
    this.toc_has_been_populated = false;
    this.toc_by_href            = {};
};
/**
    Add the given TOC item to this collection.
    @example
    var toc = new RB.Format.TOC.TOC();
    var t1 = new RB.Format.TOC.TOCItem("OEBPS/Text/p001.xhtml", null, "Chapter 1", null);
    var t2 = new RB.Format.TOC.TOCItem("OEBPS/Text/p002.xhtml", null, "Chapter 2", null);
    toc.addTOCItem(t1);
    toc.addTOCItem(t2);
    @param {RB.Format.TOC.TOCItem} tocItem - The TOC item to be added.
*/
RB.Format.TOC.TOC.prototype.addTOCItem = function(tocItem) {
    this.toc.push(tocItem);
};
/**
    Query a single TOC item by its href.
    @example
    var ti = toc.getTOCItemByHref("OEBPS/Text/p001.xhtml");
    // now ti contains the TOC item located at OEBPS/Text/p001.xhtml inside the EPUB container
    @param  {string} href - The desired TOC item href, which is the path, w.r.t. the EPUB container root, of the referenced asset (e.g., `OEBPS/Text/p001.xhtml`). Never `null`.
    @return {RB.Format.TOC.TOCItem} x- The {@link RB.Format.TOC.TOCItem} matching `href`. It might be `null` if not found.
*/
RB.Format.TOC.TOC.prototype.getTOCItemByHref = function(href) {
    if (! this.toc_has_been_populated) {
        // safety feature, in case you forgot to call it yourself
        this.computeTOCItemByHref();
    }
    return this.toc_by_href[href];
};
/**
    Populate the instance variables by parsing the given object.
    @param {object} obj - A dictionary (i.e., { key1: value1, key2: value2, ... }). 
*/
RB.Format.TOC.TOC.prototype.loadFromObject = function(obj) {
    if ((obj) && (obj.toc)) {
        obj = obj.toc;
        for (var i = 0; i < obj.length; i++) {
            var n = new RB.Format.TOC.TOCItem();
            n.loadFromObject(obj[i]);
            this.addTOCItem(n);
        }
        this.computeTOCItemByHref();
    }
};
/**
    Recursively visit the TOC tree,
    populating the dictionary mapping href to TOC items
    (`this.toc_by_href`).
    
    This method must be called after the TOC has been populated.
    
    The goal of this method consists in
    creating a map from an asset href to a (string) label,
    for subsequent manipulations.
    The idea is that the TOC node might contain a short description
    of the asset, hence can be used to describe the asset elsewhere
    (e.g., in the {@link RB.Format.Playlist.Playlist}).

    @todo This approach is fragile, and it should be superseeded
    by e.g. nav landmarks or nav loa or parsing the asset metadata.

    @example
    var toc = new RB.Format.TOC.TOC();
    var t1 = new RB.Format.TOC.TOCItem("OEBPS/Text/p001.xhtml", null, "Chapter 1", null);
    ...
    var tN = new RB.Format.TOC.TOCItem("OEBPS/Text/p00N.xhtml", null, "Chapter N", null);
    toc.addTOCItem(t1);
    ...
    toc.addTOCItem(tN);
    toc.computeTOCItemByHref()
*/
RB.Format.TOC.TOC.prototype.computeTOCItemByHref = function() {
    // set sentinel
    this.toc_by_href = {};
    add(this.toc, this.toc_by_href);
    this.toc_has_been_populated = true;
   
    // recurse 
    function add(tocItemArray, tocItemDict) {
        for (var i = 0; i < tocItemArray.length; i++) {
            var tocItem = tocItemArray[i];
            if (tocItem.href) {
                // store if not already stored, or if anchor is `null`
                if (!(tocItem.href in tocItemDict) || (tocItem.anchor === null)) {
                    tocItemDict[tocItem.href] = tocItem;
                }
            }
            if (tocItem.children) {
                add(tocItem.children, tocItemDict);
            }
        }
    }
};


/** @namespace RB.Format.SMIL */
RB.Format.SMIL = RB.Format.SMIL || {};

/**
    @classdesc A single SMIL fragment.
    @example
    var sf1 = new RB.Format.SMIL.SMILFragment("OEBPS/Text/p001.xhtml", "f000001", "OEBPS/Audio/01.mp3", 0,      12.345);
    var sf2 = new RB.Format.SMIL.SMILFragment("OEBPS/Text/p001.xhtml", "f000002", "OEBPS/Audio/01.mp3" ,12.345, 23.456);
    var sf3 = new RB.Format.SMIL.SMILFragment("OEBPS/Text/p001.xhtml", "f000003", "OEBPS/Audio/01.mp3", 23.456, 34.567);
    @class
    @param {string} text_src - The `src` of the associated text asset, which is the path, w.r.t. the EPUB container root, of the referenced asset (e.g., `OEBPS/Text/p001.xhtml`). Never `null`.
    @param {string} text_src_anchor - The anchor in the text file. Never `null`.
    @param {string} audio_src - The `src` of the associated audio asset, which is the path, w.r.t. the EPUB container root, of the referenced asset (e.g., `OEBPS/Audio/01.mp3`). Never `null`.
    @param {float} audio_clipBegin - The clipBegin attribute, in seconds. Never `null`.
    @param {float} audio_clipEnd - The clipEnd attribute, in second. The special value `-1` means that this fragment must play until the end of the audio file. Never `null`.
*/
RB.Format.SMIL.SMILFragment = RB.Format.SMIL.SMILFragment || function(text_src, text_src_anchor, audio_src, audio_clipBegin, audio_clipEnd) {
    this.text_src        = text_src;
    this.text_src_anchor = text_src_anchor;
    this.audio_src       = audio_src;
    this.audio_clipBegin = audio_clipBegin;
    this.audio_clipEnd   = audio_clipEnd;
};
/**
    Populate the instance variables by parsing the given object.
    @param {object} obj - A dictionary (i.e., { key1: value1, key2: value2, ... }). 
*/
RB.Format.SMIL.SMILFragment.prototype.loadFromObject = function(obj) {
    var instance_vars = [ "text_src", "text_src_anchor", "audio_src", "audio_clipBegin", "audio_clipEnd" ];
    if (obj) {
        for (var i = 0; i < instance_vars.length; i++) {
            var key = instance_vars[i];
            if (key in obj) {
                this[key] = obj[key];
            }
        }
    }
};


/** @namespace RB.Format.ROD */
RB.Format.ROD = RB.Format.ROD || {};

/**
    @classdesc A single ROD item.
    @example
    var ri0 = new RB.Format.ROD.RODItem("title", "OEBPS/Text/title.xhtml");
    var ri1 = new RB.Format.ROD.RODItem("p001", "OEBPS/Text/p001.xhtml", { "audio_src": ["OEBPS/Audio/01.mp3"], "duration": "12:34", "valid_mo": true });
    var ri2 = new RB.Format.ROD.RODItem("p002", "OEBPS/Text/p002.xhtml", { "audio_src": ["OEBPS/Audio/02.mp3"], "duration": "01:23:45", "valid_mo": true });
    @class
    @param {string} idref - The `id`, w.r.t. the manifest, of the referenced text asset (e.g., `p001`). Never `null`.
    @param {string} text_src - The `src` of the associated text asset, which is the path, w.r.t. the EPUB container root, of the referenced asset (e.g., `OEBPS/Text/p001.xhtml`). Never `null`.

    @param {object} info - A dictionary containing additional information about the ROD item. Supported keys are:

- `linear`: (boolean) true if and only if the spine item has linear="yes" (explicitly or implicitly)
- `audio_src`: (array) array of strings, each representing the `src` of the associated audio asset, which is the path, w.r.t. the EPUB container root, of the referenced asset (e.g., `OEBPS/Audio/01.mp3`),
- `duration`: (string) the duration, in [HH:]MM:SS format, of the associated audio asset,
- `valid_mo`: (boolean) `true` if the associated Media Overlay file is supported, `false` otherwise.
- `rendition`: (object) a dictionary containing rendition information 
*/
RB.Format.ROD.RODItem = RB.Format.ROD.RODItem || function(id, text_src, info) {
    this.id        = id;
    this.text_src  = text_src;
    this.linear    = true;
    this.audio_src = [];
    this.duration  = null;
    this.valid_mo  = null;
    this.smil_data = [];
    this.smil_ids  = [];
    this.rendition = null;
    if (info) {
        var info_keys = [ "linear", "audio_src", "duration", "valid_mo", "rendition" ];
        for (var i = 0; i < info_keys.length; i++) {
            var key = info_keys[i];
            if (key in info) {
                this[key] = info[key];
            }
        }
    }
};
/**
    Populate the instance variables by parsing the given object.
    @param {object} obj - A dictionary (i.e., { key1: value1, key2: value2, ... }). 
*/
RB.Format.ROD.RODItem.prototype.loadFromObject = function(obj) {
    var instance_vars = [ "id", "text_src", "linear", "audio_src", "duration", "valid_mo", "smil_data", "smil_ids", "rendition" ];
    if (obj) {
        for (var i = 0; i < instance_vars.length; i++) {
            var key = instance_vars[i];
            if (key in obj) {
                this[key] = obj[key];
            }
        }
    }
};
/**
    Add the given SMIL fragment to this collection.
    @example
    var ri = new RB.Format.ROD.RODItem("p001", "OEBPS/Text/p001.xhtml", { "audio_src": ["OEBPS/Audio/01.mp3"], "duration": "12:34", "valid_mo": true });
    var sf1 = new RB.Format.SMIL.SMILFragment("OEBPS/Text/p001.xhtml", "f000001", "OEBPS/Audio/01.mp3", 0,      12.345);
    var sf2 = new RB.Format.SMIL.SMILFragment("OEBPS/Text/p001.xhtml", "f000002", "OEBPS/Audio/01.mp3" ,12.345, 23.456);
    var sf3 = new RB.Format.SMIL.SMILFragment("OEBPS/Text/p001.xhtml", "f000003", "OEBPS/Audio/01.mp3", 23.456, 34.567);
    ri.addSMILFragment(sf1);
    ri.addSMILFragment(sf2);
    ri.addSMILFragment(sf3);
    @param {RB.Format.SMIL.SMILFragment} tocItem - The SMIL fragment to be added.
*/
RB.Format.ROD.RODItem.prototype.addSMILFragment = function(smilFragment) {
    this.smil_data.push(smilFragment);
    this.smil_ids.push(smilFragment.text_src_anchor);
};
/**
    Get the href of the associated text asset.
    @example
    var ri = new RB.Format.ROD.RODItem("p001", "OEBPS/Text/p001.xhtml", { "audio_src": ["OEBPS/Audio/01.mp3"], "duration": "12:34", "valid_mo": true });
    var t = ri.getTextSrc();
    //  t = "OEBPS/Text/p001.xhtml"
    @return {string} x- The `src` of the associated text asset, which is the path, w.r.t. the EPUB container root, of the referenced asset (e.g., `OEBPS/Text/p001.xhtml`).
*/
RB.Format.ROD.RODItem.prototype.getTextSrc = function () {
    return this.text_src;
};
/**
    Get the href of the associated audio asset(s).
    @example
    var ri = new RB.Format.ROD.RODItem("p001", "OEBPS/Text/p001.xhtml", { "audio_src": ["OEBPS/Audio/01.mp3"], "duration": "12:34", "valid_mo": true });
    var a = ri.getAudioSrc();
    //  a = ["OEBPS/Audio/01.mp3"]
    @return {array} x- An array of strings, each representing the `src` of the associated audio asset, which is the path, w.r.t. the EPUB container root, of the referenced asset (e.g., `OEBPS/Audio/01.mp3`). It might be `null`.
*/

RB.Format.ROD.RODItem.prototype.getAudioSrc = function () {
    return this.audio_src;
};

/**
    @classdesc A data structure to store the reading order data (ROD).
    It is roughly equivalent to the OPF `<spine>` element,
    augmented with extra data.
    This class is essentially a wrapper
    for an array of {@link RB.Format.ROD.RODItem} objects,
    and it provides specialized accessor methods,
    for example you can query the index of a ROD item by its href.
    @example
    var rod = new RB.Format.ROD.ROD();
    @class
*/
RB.Format.ROD.ROD = RB.Format.ROD.ROD || function() {
    this.rod               = [];
    this.rod_index_by_href = {};
};
/**
    Add the given ROD item to this collection.
    @example
    var rod = new RB.Format.ROD.ROD();
    var ri1 = new RB.Format.ROD.RODItem("p001", "OEBPS/Text/p001.xhtml", { "audio_src": ["OEBPS/Audio/01.mp3"], "duration": "12:34", "valid_mo": true });
    var ri2 = new RB.Format.ROD.RODItem("p002", "OEBPS/Text/p002.xhtml", { "audio_src": ["OEBPS/Audio/02.mp3"], "duration": "23:45", "valid_mo": true });
    var ri3 = new RB.Format.ROD.RODItem("p003", "OEBPS/Text/p003.xhtml", { "audio_src": ["OEBPS/Audio/03.mp3"], "duration": "34:45", "valid_mo": true });
    rod.addRODItem(ri1);
    rod.addRODItem(ri2);
    rod.addRODItem(ri3);
    @param {RB.Format.ROD.RODItem} rodItem - The ROD item to be added.
*/
RB.Format.ROD.ROD.prototype.addRODItem = function(rodItem) {
    this.rod.push(rodItem);
    if (rodItem.text_src) {
        this.rod_index_by_href[rodItem.text_src] = this.rod.length - 1;
    }
};
/**
    Query a ROD item by its href.
    @example
    var rod = new RB.Format.ROD.ROD();
    var ri1 = new RB.Format.ROD.RODItem("p001", "OEBPS/Text/p001.xhtml", { "audio_src": ["OEBPS/Audio/01.mp3"], "duration": "12:34", "valid_mo": true });
    var ri2 = new RB.Format.ROD.RODItem("p002", "OEBPS/Text/p002.xhtml", { "audio_src": ["OEBPS/Audio/02.mp3"], "duration": "23:45", "valid_mo": true });
    var ri3 = new RB.Format.ROD.RODItem("p003", "OEBPS/Text/p003.xhtml", { "audio_src": ["OEBPS/Audio/03.mp3"], "duration": "34:45", "valid_mo": true });
    rod.addRODItem(ri1);
    rod.addRODItem(ri2);
    rod.addRODItem(ri3);
    var ri = rod.getRODIndexByHref("OEBPS/Text/p002.xhtml"); // ri = ri2
        ri = rod.getRODIndexByHref("OEBPS/Text/foo.xhtml");  // ri = null
    @param  {string} href - The desired ROD item href, which is the path, w.r.t. the EPUB container root, of the referenced asset (e.g., `OEBPS/Text/p001.xhtml`). Never `null`.
    @return {RB.Format.ROD.RODItem} x- The {@link RB.Format.ROD.RODItem} matching `href`. It might be `null` if not found.
*/
RB.Format.ROD.ROD.prototype.getRODItemByHref = function(href) {
    if (href) {
        return this.rod[this.rod_index_by_href[href]];
    }
    return null;
};
/**
    Query the index of a ROD item by its href.
    @example
    var rod = new RB.Format.ROD.ROD();
    var ri1 = new RB.Format.ROD.RODItem("p001", "OEBPS/Text/p001.xhtml", { "audio_src": ["OEBPS/Audio/01.mp3"], "duration": "12:34", "valid_mo": true });
    var ri2 = new RB.Format.ROD.RODItem("p002", "OEBPS/Text/p002.xhtml", { "audio_src": ["OEBPS/Audio/02.mp3"], "duration": "23:45", "valid_mo": true });
    var ri3 = new RB.Format.ROD.RODItem("p003", "OEBPS/Text/p003.xhtml", { "audio_src": ["OEBPS/Audio/03.mp3"], "duration": "34:45", "valid_mo": true });
    rod.addRODItem(ri1);
    rod.addRODItem(ri2);
    rod.addRODItem(ri3);
    var index = rod.getRODIndexByHref("OEBPS/Text/p002.xhtml"); // index = 1
        index = rod.getRODIndexByHref("OEBPS/Text/foo.xhtml");  // index = null
    @param  {string} href - The desired ROD item href, which is the path, w.r.t. the EPUB container root, of the referenced asset (e.g., `OEBPS/Text/p001.xhtml`). Never `null`.
    @return {int} x- The index of the {@link RB.Format.ROD.RODItem} matching `href`. It might be `null` if not found.
*/
RB.Format.ROD.ROD.prototype.getRODIndexByHref = function(href) {
    if (href) {
        return this.rod_index_by_href[href];
    }
    return null;
};
/**
    Populate the instance variables by parsing the given object.
    @param {object} obj - A dictionary (i.e., { key1: value1, key2: value2, ... }). 
*/
RB.Format.ROD.ROD.prototype.loadFromObject = function(obj) {
    if ((obj) && (obj.rod)) {
        obj = obj.rod;
        for (var i = 0; i < obj.length; i++) {
            var n = new RB.Format.ROD.RODItem();
            n.loadFromObject(obj[i]);
            this.addRODItem(n);
        }
    }
};


/** @namespace RB.Format.Playlist */
RB.Format.Playlist = RB.Format.Playlist || {};

/**
    @classdesc A single Playlist item.
    @example
    var pi = new RB.Format.Playlist.PlaylistItem("OEBPS/Text/p001.xhtml", "Chapter 1", "12:34");
    @class
    @param {string} href - The href of the associated text asset, which is the path, w.r.t. the EPUB container root, of the referenced asset (e.g., `OEBPS/Text/p001.xhtml`). Never `null`.
    @param {string} label - The label for this item. It might be `null` (e.g., to signal that the parser was not able to associate a suitable label).
    @param {string} duration - The duration, in [HH:]MM:SS format, of the associated audio asset. Never `null`.
*/
RB.Format.Playlist.PlaylistItem = RB.Format.Playlist.PlaylistItem || function(href, label, duration) {
    this.href     = href;
    this.label    = label;
    this.duration = duration;
};
/**
    Populate the instance variables by parsing the given object.
    @param {object} obj - A dictionary (i.e., { key1: value1, key2: value2, ... }). 
*/
RB.Format.Playlist.PlaylistItem.prototype.loadFromObject = function(obj) {
    var instance_vars = [ "href", "label", "duration" ];
    if (obj) {
        for (var i = 0; i < instance_vars.length; i++) {
            var key = instance_vars[i];
            if (key in obj) {
                this[key] = obj[key];
            }
        }
    }
};

/**
    @classdesc A data structure to store the playlist data.
    This class is essentially a wrapper for an array of {@link RB.Format.Playlist.PlaylistItem} objects.
    @example
    var p = new RB.Format.Playlist.Playlist();
    @class
*/
RB.Format.Playlist.Playlist = RB.Format.Playlist.Playlist || function() {
    this.playlist               = [];
    this.playlist_index_by_href = {};
};
/**
    Add the given Playlist item to this collection.
    @example
    var p = new RB.Format.Playlist.Playlist();
    var pi = new RB.Format.Playlist.PlaylistItem("OEBPS/Text/p001.xhtml", "Chapter 1", "12:34");
    p.addPlaylistItem(pi);
    @param {RB.Format.PlaylistItem} playlistItem - The Playlist item to be added.
*/
RB.Format.Playlist.Playlist.prototype.addPlaylistItem = function(playlistItem) {
    this.playlist.push(playlistItem);
    if (playlistItem.href) {
        this.playlist_index_by_href[playlistItem.href] = this.playlist.length - 1;
    }
};
RB.Format.Playlist.Playlist.prototype.getPlaylistItemByHref = function(href) {
    if (href) {
        return this.playlist[this.playlist_index_by_href[href]];
    }
    return null;
};
RB.Format.Playlist.Playlist.prototype.getPlaylistItemIndexByHref = function(href) {
    if (href) {
        return this.playlist_index_by_href[href];
    }
    return null;
};
/**
    Populate the instance variables by parsing the given object.
    @param {object} obj - A dictionary (i.e., { key1: value1, key2: value2, ... }). 
*/
RB.Format.Playlist.Playlist.prototype.loadFromObject = function(obj) {
    if ((obj) && (obj.playlist)) {
        obj = obj.playlist;
        for (var i = 0; i < obj.length; i++) {
            var n = new RB.Format.Playlist.PlaylistItem();
            n.loadFromObject(obj[i]);
            this.addPlaylistItem(n);
        }
    }
};


/** @namespace RB.Format.EPUB */
RB.Format.EPUB = RB.Format.EPUB || {};

/**
    The criterion for determining the ROD index
    at which the book should be opened (the first time).
    Note: currently, EPUB 3 landmarks bodymatter is not supported.
    @todo Use Object.freeze to freeze the enum. (Currently not in place, due to a JSDoc bug.)
    @todo Add EPUB 3 landmarks bodymatter.
    @readonly
    @enum {string}
*/
RB.Format.EPUB.OpenBookAtEnum = {
    /** `<guide>` item with `text` property */
    EPUB2_GUIDE_TEXT:   "epub2:guide:text",

    /** first spine item with linear="yes" */
    EPUB_SPINE_LINEAR:  "epub:spine:linear",
    
    /** first manifest item with `media-overlay` property */
    EPUB3_ROD_MO:       "epub3:rod:mo"
};
/**
    Allowed values for `rendition:flow`.
    @todo Use Object.freeze to freeze the enum. (Currently not in place, due to a JSDoc bug.)
    @readonly
    @enum {string}
*/
RB.Format.EPUB.RenditionFlowEnum = {
    /** paginated */
    PAGINATED:              "paginated",

    /** scrolled-continuous */
    SCROLLED_CONTINUOUS:    "scrolled-continuous",

    /** scrolled-doc */
    SCROLLED_DOC:           "scrolled-doc",

    /** auto */
    AUTO:                   "auto"
};
/**
    Allowed values for `rendition:layout`.
    @todo Use Object.freeze to freeze the enum. (Currently not in place, due to a JSDoc bug.)
    @readonly
    @enum {string}
*/
RB.Format.EPUB.RenditionLayoutEnum = {
    /** reflowable */
    REFLOWABLE:     "reflowable",
    
    /** pre-paginated */
    PRE_PAGINATED:  "pre-paginated"
};
/**
    Allowed values for `rendition:orientation`.
    @todo Use Object.freeze to freeze the enum. (Currently not in place, due to a JSDoc bug.)
    @readonly
    @enum {string}
*/
RB.Format.EPUB.RenditionOrientationEnum = {
    /** landscape */
    LANDSCAPE:  "landscape",
    
    /** portrait */
    PORTRAIT:   "portrait",

    /** auto */
    AUTO:       "auto"
};
/**
    Allowed values for `rendition:spread`.
    @todo Use Object.freeze to freeze the enum. (Currently not in place, due to a JSDoc bug.)
    @readonly
    @enum {string}
*/
RB.Format.EPUB.RenditionSpreadEnum = {
    /** none */
    NONE:       "none",
    
    /** landscape */
    LANDSCAPE:  "landscape",
    
    /** portrait */
    PORTRAIT:   "portrait",
    
    /** both */
    BOTH:       "both",
    
    /** auto */
    AUTO:       "auto"
};
/**
    EPUB 3 Core Media Types.
    @todo Use Object.freeze to freeze the enum. (Currently not in place, due to a JSDoc bug.)
    @readonly
    @enum {string}
*/
RB.Format.EPUB.CoreMediaTypesEnum = {
    /** image/gif */
    GIF:    "image/gif",

    /** image/jpeg */
    JPEG:   "image/jpeg",

    /** image/png */
    PNG:    "image/png",

    /** image/svg+xml */
    SVG:    "image/svg+xml",

    /** application/xhtml+xml */
    XHTML:  "application/xhtml+xml",

    /** application/x-dtbncx+xml */
    NCX:    "application/x-dtbncx+xml",

    /** application/vnd.ms-opentype */
    OTF:    "application/vnd.ms-opentype",

    /** application/font-woff */
    WOFF:   "application/font-woff",

    /** application/smil+xml */
    SMIL:   "application/smil+xml",

    /** application/pls+xml */
    PLS:    "application/pls+xml",

    /** audio/mpeg */
    MP3:    "audio/mpeg",

    /** audio/mp4 */
    MP4:    "audio/mp4",

    /** text/css */
    CSS:    "text/css",

    /** text/javascript */
    JS:     "text/javascript"
};

/**
    @classdesc A data structure representing an EPUB 2 or EPUB 3 main data: metadata, manifest, spine, TOC.
    @example
    // just build an empty EPUB
    var e = new RB.Format.EPUB.EPUB();

    // build the EPUB by parsing the contents of path/to/my/dir/ (where you previously unzipped the EPUB file)
    var e = new RB.Format.EPUB.EPUB("path/to/my/dir/");

    // as above, but perform full parsing (build ROD and Playlist, and parse MO)
    var e = new RB.Format.EPUB.EPUB("path/to/my/dir/", { "full_parsing": true });

    // as above, but do not parse Media Overlay (SMIL) files
    var e = new RB.Format.EPUB.EPUB("path/to/my/dir/", { "full_parsing": true, "incremental_mo_parsing": true });

    // as above, but do not perform a full parsing and use lenient parsing
    var e = new RB.Format.EPUB.EPUB("path/to/my/dir/", { "full_parsing": false, "lenient_parsing": true });

    // restore the EPUB from a JSON object, e.g. loaded from storage
    var s = JSON.parse(some_string_loaded_from_storage);
    var e = new RB.Format.EPUB.EPUB(s);
    @class
    @param {object} obj - If `obj` is a string, it represents the path to the directory where the EPUB has been unzipped. If `obj` is a object, try restoring the EPUB from the JSON object `obj`.  It might be `null`/`undefined`, e.g. when you want to create an empty EPUB object (this will be useful in a later, more complete version of this library).
    @param {object} args - A dictionary (i.e., { key1: value1, key2: value2, ... }) containing optional parameters. Currently, the allowed keys are:

- `full_parsing` (boolean, default: `false`): if `true`, build the extra data (ROD and Playlist) for Minstrel app
- `incremental_mo_parsing` (boolean, default: `false`): if `true`, do not parse Media Overlay (SMIL) files
- `lenient_parsing` (boolean, default: `false`): if `true`, do not throw exception for non-fatal errors

It might be `null`/`undefined`. This parameter is ignored if `obj` is not a string.
*/
RB.Format.EPUB.EPUB = RB.Format.EPUB.EPUB || function(obj, args) {

    // string representing the path of the directory where the EPUB has been unzipped
    this.unpacked_directory     = null;
  
    // if true, build ROD and playlist
    this.full_parsing           = false;
   
    // if true, while building ROD do not parse MO
    this.incremental_mo_parsing = false;

    // if true, do not throw exception for non-fatal errors
    this.lenient_parsing        = false;

    // exception tag
    this.exception_tag          = "Format.EPUB";

    // common variables
    this.opf_directory          = null;
    this.opf_file_path          = null;
    this.ncx_file_path          = null;
    this.nav_file_path          = null;
    this.fully_parsed           = false;
    this.has_media_overlays     = false;
    this.has_mathml             = false;
    this.has_remote_resources   = false;
    this.has_scripted           = false;
    this.has_svg                = false;
    this.has_switch             = false;
    this.has_encrypted_assets   = false;

    // EPUB metadata
    this.epub_metadata          = new RB.Format.OPF.Metadata(); 

    // EPUB manifest
    this.epub_manifest          = new RB.Format.OPF.Manifest();

    // EPUB spine
    this.epub_spine             = new RB.Format.OPF.Spine();

    // EPUB TOC
    this.epub_toc               = new RB.Format.TOC.TOC();

    // EPUB ROD
    this.epub_rod               = new RB.Format.ROD.ROD();

    // EPUB playlist
    this.epub_playlist          = new RB.Format.Playlist.Playlist();

    // initialize
    if (obj) {
        if (typeof obj === "string") {
            this.loadFromDirectory(obj, args);
        }

        if (typeof obj === "object") {
            this.loadFromJSON(obj);
        }
    }
};



/* GETTERS */
/**
    Get the path to the directory where the EPUB has been unpacked to.
    @example
    var e = new RB.Format.EPUB.EPUB("path/to/my/dir/");
    var s = e.getUnpackedDirectory();
    //  s = "path/to/my/dir/"
    @return {string} x- The path to the directory where the EPUB has been unpacked to.
*/
RB.Format.EPUB.EPUB.prototype.getUnpackedDirectory = function() {
    return this.unpacked_directory;
};
/**
    Get the path of the OPF file, relative to the EPUB container root.
    @example
    var e = new RB.Format.EPUB.EPUB("path/to/my/dir/");
    var s = e.getOPFFilePath();
    //  s = "OEBPS/content.opf"
    @return {string} x- The path of the OPF file, relative to the EPUB container root.
*/
RB.Format.EPUB.EPUB.prototype.getOPFFilePath = function() {
    return this.opf_file_path;
};
/**
    Get the path of the NCX TOC file, relative to the EPUB container root.
    @example
    var e = new RB.Format.EPUB.EPUB("path/to/my/dir/");
    var s = e.getNCXFilePath();
    //  s = "OEBPS/toc.ncx"
    @return {string} x- The path of the NCX TOC file, relative to the EPUB container root, or `null` if not present.
*/
RB.Format.EPUB.EPUB.prototype.getNCXFilePath = function() {
    return this.ncx_file_path;
};
/**
    Get the path of the XHTML nav TOC file, relative to the EPUB container root.
    @example
    var e = new RB.Format.EPUB.EPUB("path/to/my/dir/");
    var s = e.getNavFilePath();
    //  s = "OEBPS/toc.xhtml"
    @return {string} x- The path of the XHTML nav TOC file, relative to the EPUB container root, or `null` if not present.
*/
RB.Format.EPUB.EPUB.prototype.getNavFilePath = function() {
    return this.nav_file_path;
};
/**
    Query whether the EPUB has been fully parsed (i.e., ROD and Playlist has been computed) or not.
    @example
    var e = new RB.Format.EPUB.EPUB("path/to/my/dir/");
    var s = e.isFullyParsed();
    //  s = true
    @return {boolean} x- `true` if the EPUB has been fully parsed, `false` otherwise.
*/
RB.Format.EPUB.EPUB.prototype.isFullyParsed = function() {
    return this.fully_parsed;
};
/**
    Query whether the EPUB has assets with Media Overlays.
    @example
    var e = new RB.Format.EPUB.EPUB("path/to/my/dir/");
    var s = e.hasMediaOverlays();
    //  s = true
    @return {boolean} x- `true` if the EPUB has at least one manifest item with `media-overlay` attribute, `false` otherwise.
*/
RB.Format.EPUB.EPUB.prototype.hasMediaOverlays = function() {
    return this.has_media_overlays;
};
/**
    Query whether the EPUB has assets with MathML.
    @example
    var e = new RB.Format.EPUB.EPUB("path/to/my/dir/");
    var s = e.hasMathML();
    // s = false
    @return {boolean} x- `true` if the EPUB has at least one manifest item with `mathml` in the properties attribute, `false` otherwise.
*/
RB.Format.EPUB.EPUB.prototype.hasMathML = function() {
    return this.has_mathml;
};
/**
    Query whether the EPUB has assets with remote resources.
    @example
    var e = new RB.Format.EPUB.EPUB("path/to/my/dir/");
    var s = e.hasRemoteResources();
    //  s = true
    @return {boolean} x- `true` if the EPUB has at least one manifest item with `remote-resources` in the properties attribute, `false` otherwise.
*/
RB.Format.EPUB.EPUB.prototype.hasRemoteResources = function() {
    return this.has_remote_resources;
};
/**
    Query whether the EPUB has scripted assets.
    @example
    var e = new RB.Format.EPUB.EPUB("path/to/my/dir/");
    var s = e.hasScripted();
    //  s = false
    @return {boolean} x- `true` if the EPUB has at least one manifest item with `scripted` in the properties attribute, `false` otherwise.
*/
RB.Format.EPUB.EPUB.prototype.hasScripted = function() {
    return this.has_scripted;
};
/**
    Query whether the EPUB has SVG assets.
    @example
    var e = new RB.Format.EPUB.EPUB("path/to/my/dir/");
    var s = e.hasSVG();
    //  s = true
    @return {boolean} x- `true` if the EPUB has at least one manifest item with `svg` in the properties attribute, `false` otherwise.
*/
RB.Format.EPUB.EPUB.prototype.hasSVG = function() {
    return this.has_svg;
};
/**
    Query whether the EPUB has assets with the `switch` element.
    @example
    var e = new RB.Format.EPUB.EPUB("path/to/my/dir/");
    var s = e.hasSwitch();
    //  s = true
    @return {boolean} x- `true` if the EPUB has at least one manifest item with `switch` in the properties attribute, `false` otherwise.
*/
RB.Format.EPUB.EPUB.prototype.hasSwitch = function() {
    return this.has_switch;
};
/**
    Query whether the EPUB has encrypted assets.
    Currently, this method just probes the existence of file `META-INF/encryption.xml`.
    Since it is likely its assets are obfuscated (DRM'ed),
    you might want to use only the OPF information from this EPUB.
    @example
    var e = new RB.Format.EPUB.EPUB("path/to/my/dir/");
    var s = e.hasEncryptedAssets();
    //  s = true
    @return {boolean} x- `true` if the EPUB has encrypted assets, `false` otherwise.
*/
RB.Format.EPUB.EPUB.prototype.hasEncryptedAssets = function() {
    return this.has_encrypted_assets;
};
/**
    Query metadata values with a given name.
    @example
    // suppose the EPUB has two dc:creator elements:
    // one for author Foo Bar, the other for translator Baz Baz
    var e = new RB.Format.EPUB.EPUB("path/to/my/dir/");
    var v1 = e.getMetadatumValue(RB.Format.OPF.Metadatum.NameEnum.DC_CREATOR, true, false);
    //  v1 = "Foo Bar"
    var v2 = e.getMetadatumValue(RB.Format.OPF.Metadatum.NameEnum.DC_CREATOR, false, false);
    //  v2 = "Foo Bar; Baz Baz"
    var v3 = e.getMetadatumValue(RB.Format.OPF.Metadatum.NameEnum.DC_CREATOR, false, true);
    //  v3 = ["Foo Bar", "Baz Baz"]
    @param  {RB.Format.OPF.Metadatum.NameEnum} name - The desired metadata name.
    @param  {boolean} only_first - If `true`, returns only the value of the first {@link RB.Format.OPF.Metadatum} with given name. If `false`, returns all matching metadata objects.
    @param  {boolean} as_string - If `true`, concatenates the matching metadata values into a single string. If `false`, returns them as an array of strings.
    @return {object} x- A `string` or an array of `string`s, containing the matching metadata values. It might be `null` if not found.
*/
RB.Format.EPUB.EPUB.prototype.getMetadatumValue = function(name, only_first, as_string) {
    return this.epub_metadata.getMetadatumValue(name, only_first, as_string);
};
/**
    Get the path of the cover image file, relative to the EPUB container root.
    For EPUB 3 files, this is the path to the manifest item with `cover-image` in the `properties` attribute.
    For EPUB 2 files, this is the path to the manifest item with a corresponding `<meta>` with name `cover`.
    @example
    var e = new RB.Format.EPUB.EPUB("path/to/my/dir/");
    var c = e.getCover();
    //  c = "OEBPS/Images/cover.jpg"
    @return {string} x- The path of the cover image file, relative to the EPUB container root, or `null` if not present.
*/
RB.Format.EPUB.EPUB.prototype.getCover = function() {
    // EPUB 3 cover
    var c = this.epub_metadata.getMetadatumValue(RB.Format.OPF.Metadatum.NameEnum.EPUB3_COVER, true, true);
    if (c) {
        return this.epub_manifest.getManifestItemById(c).href;
    }

    // EPUB 2 cover
    var c = this.epub_metadata.getMetadatumValue(RB.Format.OPF.Metadatum.NameEnum.EPUB2_COVER, true, true);
    if (c) {
        return this.epub_manifest.getManifestItemById(c).href;
    }

    return null;
};
/**
    Get the total media duration of the EPUB 3 publication, as specified by `<meta property="media:duration">...</meta>`.
    @example
    var e = new RB.Format.EPUB.EPUB("path/to/my/dir/");
    var d = e.getMediaDuration(false, false);
    //  d = "3723"
    var d = e.getMediaDuration(true, false);
    //  d = "01:02:03"
    var d = e.getMediaDuration(true, true);
    //  d = "01:02:03", since the duration is longer than one hour
    @param {boolean} pretty - If `true`, return the duration in HH:MM:SS format; otherwise, return the duration as written in the OPF file.
    @param {boolean} no_hours - If the duration is less than one hour, return the duration in MM:SS format. Otherwise, in HH:MM:SS format. This option applies if and only if `pretty` is `true`.
    @return {string} x- The total media duration, formatted according to the given options, or `null` if not present.
*/
RB.Format.EPUB.EPUB.prototype.getMediaDuration = function(pretty, no_hours) {
    var v = this.epub_metadata.getMetadatumValue(RB.Format.OPF.Metadatum.NameEnum.MEDIA_DURATION_TOTAL, true, true);
    if ((v) && (pretty)) {
        // a string, containing the media:duration value, in HH:MM:SS or HH:MM:SS.mmm format
        var seconds = RB.Utilities.clockValueToSeconds(v);
        return RB.Utilities.prettifyClockValue(seconds, no_hours); 
    } else {
        // a string, containing the media:duration value, exactly as written in the OPF file
        return v;
    }
};
/**
    Return the metadata object of this EPUB.
    @example
    var e = new RB.Format.EPUB.EPUB("path/to/my/dir/");
    var m = e.getMetadata();
    @return {RB.Format.OPF.Metadata} x- The metadata.
*/
RB.Format.EPUB.EPUB.prototype.getMetadata = function() {
    return this.epub_metadata;
};
/**
    Return the manifest object of this EPUB.
    @example
    var e = new RB.Format.EPUB.EPUB("path/to/my/dir/");
    var m = e.getManifest();
    @return {RB.Format.OPF.Manifest} x- The manifest.
*/
RB.Format.EPUB.EPUB.prototype.getManifest = function() {
    return this.epub_manifest;
};
/**
    Return the spine object of this EPUB.
    @example
    var e = new RB.Format.EPUB.EPUB("path/to/my/dir/");
    var s = e.getSpine();
    @return {RB.Format.OPF.Spine} x- The spine.
*/
RB.Format.EPUB.EPUB.prototype.getSpine = function() {
    return this.epub_spine;
};
/**
    Return the TOC object of this EPUB.
    @example
    var e = new RB.Format.EPUB.EPUB("path/to/my/dir/");
    var t = e.getTOC();
    @return {RB.Format.TOC.TOC} x- The TOC.
*/
RB.Format.EPUB.EPUB.prototype.getTOC = function() {
    return this.epub_toc;
};
/**
    Return the ROD object of this EPUB.
    @example
    var e = new RB.Format.EPUB.EPUB("path/to/my/dir/");
    var r = e.getROD();
    @return {RB.Format.ROD.ROD} x- The ROD.
*/
RB.Format.EPUB.EPUB.prototype.getROD = function() {
    return this.epub_rod;
};

/**
    Get the ROD index at which the book should be opened (the first time),
    according to the given criterion.
    @todo Parse nav landmarks and add "bodymatter" as a possible option.
    @example
    var e = new RB.Format.EPUB.EPUB("path/to/my/dir/");
    var index_g = e.getOpenBookAtRODItemIndex(RB.Format.EPUB.OpenBookAtEnum.EPUB2_GUIDE_TEXT);
    //  index_g = 2
    var index_s = e.getOpenBookAtRODItemIndex(RB.Format.EPUB.OpenBookAtEnum.EPUB_SPINE_LINEAR);
    //  index_s = 0
    var index_m = e.getOpenBookAtRODItemIndex(RB.Format.EPUB.OpenBookAtEnum.EPUB3_ROD_MO);
    //  index_m = 5
    @param {RB.Format.EPUB.OpenBookAtEnum} meta - Select the asset (XHTML page) at which the book should be opened.
    @return {int} x- The requested ROD index, or `null` if not found.
*/
RB.Format.EPUB.EPUB.prototype.getOpenBookAtRODItemIndex = function(meta) {
    /*
    if (meta === RB.Format.EPUB.OpenBookAtEnum.EPUB3_LANDMARKS_BODYMATTER) {

    }
    */

    // return EPUB 2 guide element with "text" value
    if (meta === RB.Format.EPUB.OpenBookAtEnum.EPUB2_GUIDE_TEXT) {
        var href = this.getMetadatumValue(RB.Format.OPF.Metadatum.NameEnum.EPUB2_GUIDE_TEXT, true, true);
        if ((href) && (this.epub_rod)) {
            return this.epub_rod.getRODIndexByHref(href);
        }
    }
    
    // return first element in spine with linear=yes 
    if (meta === RB.Format.EPUB.OpenBookAtEnum.EPUB_SPINE_LINEAR) {
        if (this.epub_spine) {
            for (var i = 0; i < this.epub_spine.spine.length; i++) {
                if (this.epub_spine.spine[i].linear === "yes") {
                    return i;
                }
            }
        }
    }

    // return first element in ROD with valid Media Overlay
    if (meta === RB.Format.EPUB.OpenBookAtEnum.EPUB3_ROD_MO) {
        if (this.epub_rod) {
            for (var i = 0; i < this.epub_rod.rod.length; i++) {
                if (this.epub_rod.rod[i].valid_mo) {
                    return i;
                }
            }
        }
    }
    
    return null;
};
/**
    Return the Playlist object of this EPUB.
    @example
    var e = new RB.Format.EPUB.EPUB("path/to/my/dir/");
    var p = e.getPlaylist();
    @return {RB.Format.Playlist.Playlist} x- The Playlist.
*/
RB.Format.EPUB.EPUB.prototype.getPlaylist = function() {
    return this.epub_playlist;
};



/* PARSING/UNMARSHALLING */
/**
    Populate the instance variables by parsing the contents of the specified directory,
    where you previously unzipped the EPUB.
    @todo Move this into a parser object
    @example
    // build the EPUB by parsing the contents of path/to/my/dir/ (where you previously unzipped the EPUB file)
    var e = new RB.Format.EPUB.EPUB();
    e.loadFromDirectory("path/to/my/dir/");

    // as above, but perform full parsing (build ROD and Playlist, and parse MO)
    var e = new RB.Format.EPUB.EPUB();
    e.loadFromDirectory("path/to/my/dir/", { "full_parsing": true });

    // as above, but do not parse Media Overlay (SMIL) files
    var e = new RB.Format.EPUB.EPUB();
    e.loadFromDirectory("path/to/my/dir/", { "full_parsing": true, "incremental_mo_parsing": true });

    // as above, but do not perform a full parsing and use lenient parsing
    var e = new RB.Format.EPUB.EPUB();
    e.loadFromDirectory("path/to/my/dir/", { "full_parsing": false, "lenient_parsing": true });

    @param {string} directory - Path to the directory where the EPUB has been unzipped. Never `null`.
    @param {object} args - A dictionary (i.e., { key1: value1, key2: value2, ... }) containing optional parameters. Currently, the allowed keys are:

- `full_parsing` (boolean, default: `false`): if `true`, build the extra data (ROD and Playlist) for Minstrel app
- `incremental_mo_parsing` (boolean, default: `false`): if `true`, do not parse Media Overlay (SMIL) files
- `lenient_parsing` (boolean, default: `false`): if `true`, do not throw exception for non-fatal errors

Ignored if `obj` is not a string. It might be `null`/`undefined`.
*/
RB.Format.EPUB.EPUB.prototype.loadFromDirectory = function(directory, args) {
    // store arguments, if given
    if (args) {
        if ("full_parsing" in args) {
            this.full_parsing           = args["full_parsing"];
        }
        if ("incremental_mo_parsing" in args) {
            this.incremental_mo_parsing = args["incremental_mo_parsing"];
        }
        if ("lenient_parsing" in args) {
            this.lenient_parsing        = args["lenient_parsing"];
        }
    }

    // did we get a (path) string?    
    if ((directory) && (typeof directory === "string")) {
        this.unpacked_directory = directory;
        
        // perform parsing 
        this.parseContainer();
        this.parseOPF();
        this.parseTOC();

        // RB stuff
        if (this.full_parsing) {
            this.buildROD();
            if (this.has_media_overlays) {
                this.buildPlaylist();
            }
            this.fully_parsed = true;
        }
    }
};
/**
    Populate the instance variables by parsing the given object.
    @todo Move this into a parser object
    @example
    // restore EPUB from a JSON object, e.g. loaded from storage
    var s = JSON.parse(some_string_loaded_from_storage);
    var e = new RB.Format.EPUB.EPUB();
    e.loadFromJSON(s);
    @param {object} obj - A dictionary (i.e., { key1: value1, key2: value2, ... }), created by `JSON.parse()` acting over a suitable string. 
*/
RB.Format.EPUB.EPUB.prototype.loadFromJSON = function(arg) {
    var instance_vars = [
        "unpacked_directory",
        "full_parsing",
        "incremental_mo_parsing",
        "lenient_parsing",
        "opf_directory",
        "opf_file_path",
        "ncx_file_path",
        "nav_file_path",
        "fully_parsed",
        "has_media_overlays",
        "has_mathml",
        "has_remote_resources",
        "has_scripted",
        "has_svg",
        "has_switch",
        "has_encrypted_assets"
    ];

    // try to rebuild the EPUB object
    for (var i = 0; i < instance_vars.length; i++) {
        var instance_var = instance_vars[i];
        if (instance_var in arg) {
            this[instance_var] = arg[instance_var];
        }
    }
   
    // metadata
    if ("epub_metadata" in arg) {
        this.epub_metadata.loadFromObject(arg["epub_metadata"]);
    }

    // manifest
    if ("epub_manifest" in arg) {
        this.epub_manifest.loadFromObject(arg["epub_manifest"]);
    }

    // spine
    if ("epub_spine" in arg) {
        this.epub_spine.loadFromObject(arg["epub_spine"]);
    }

    // toc
    if ("epub_toc" in arg) {
        this.epub_toc.loadFromObject(arg["epub_toc"]);
    }

    // rod 
    if ("epub_rod" in arg) {
        this.epub_rod.loadFromObject(arg["epub_rod"]);
    }
    
    // playlist 
    if ("epub_playlist" in arg) {
        this.epub_playlist.loadFromObject(arg["epub_playlist"]);
    }
};



/* "PRIVATE" METHODS */
/**
    parse the EPUB container (META-INF stuff)
    @todo Currently multiple `<rootfile>` elements in `container.xml` are not supported, only the first one is parsed.
    @private
*/
RB.Format.EPUB.EPUB.prototype.parseContainer = function() {
    var container_file_path    = "META-INF/container.xml";
    var container_file_content = RB.Utilities.loadXMLFile(this.unpacked_directory + container_file_path);
    if (container_file_content) {
        // TODO: currently multiple `<rootfile>` elements are not supported
        // querySelector returns only the first rootfile element
        var el = container_file_content.querySelector("rootfile");
        if (el !== null) {
            this.opf_file_path = el.getAttribute("full-path");
            if (this.opf_file_path === null) {
                throw new RB.Exception(this.exception_tag, "Cannot find 'full-path' in '" + container_file_path + "'");
            }
            this.opf_directory = RB.Utilities.getParentDirectory(this.opf_file_path);
        } else {
            throw new RB.Exception(this.exception_tag, "Cannot find 'rootfile' in '" + container_file_path + "'");
        }
    } else {
        throw new RB.Exception(this.exception_tag, "Cannot parse '" + container_file_path + "'");
    }

    try {
        var encryption_file_path    = "META-INF/encryption.xml";
        var encryption_file_content = RB.Utilities.loadXMLFile(this.unpacked_directory + encryption_file_path);
        if (encryption_file_content) {
            this.has_encrypted_assets = true;
        }
    } catch (e) {
        // there is no encryption.xml file
        this.has_encrypted_assets = false;
    }

};
/**
    parse OPF file
    @private
*/
RB.Format.EPUB.EPUB.prototype.parseOPF = function() {
    var opf_file_content = RB.Utilities.loadXMLFile(this.unpacked_directory + this.opf_file_path);
    if (opf_file_content !== null) {
        var el;

        // get version
        var got_version = false;
        el = opf_file_content.querySelector("package");
        if (el !== null) {
            if (el.getAttribute("version")) {
                var v = new RB.Format.OPF.Metadatum(null, RB.Format.OPF.Metadatum.NameEnum.EPUB_VERSION, el.getAttribute("version"), null);
                this.epub_metadata.addMetadatum(v);
                got_version = true;
            }
        }
        if ((! got_version) && (! this.lenient_parsing)) {
            throw new RB.Exception(this.exception_tag, "Cannot get EPUB version from '" + this.opf_file_path + "'");
        }

        // parse metadata
        el = opf_file_content.querySelector("metadata");
        if (el !== null) {
            this.parseOPFMetadata(el);
        } else {
            throw new RB.Exception(this.exception_tag, "Cannot get EPUB metadata from '" + this.opf_file_path + "'");
        }

        // parse manifest
        el = opf_file_content.querySelector("manifest");
        if (el !== null) {
            this.parseOPFManifest(el);
        } else {
            throw new RB.Exception(this.exception_tag, "Cannot get EPUB manifest from '" + this.opf_file_path + "'");
        }

        // parse spine
        el = opf_file_content.querySelector("spine");
        if (el !== null) {
            this.parseOPFSpine(el);
        } else {
            throw new RB.Exception(this.exception_tag, "Cannot get EPUB spine from '" + this.opf_file_path + "'");
        }

        // parse guide (optional => no error if not found)
        el = opf_file_content.querySelector("guide");
        if (el !== null) {
            this.parseOPFGuide(el);
        }

        // get unique-identifier
        // NOTE: we need to parse it AFTER having parsed the metadata
        var got_unique_identifier = false;
        el = opf_file_content.querySelector("package");
        if (el !== null) {
            var metadatum_id = el.getAttribute("unique-identifier");
            if (metadatum_id) {
                var metadatum = this.epub_metadata.getMetadatumById(metadatum_id);
                if ((metadatum) && (metadatum.value)) {
                    var u = new RB.Format.OPF.Metadatum(null, RB.Format.OPF.Metadatum.NameEnum.EPUB_UNIQUE_IDENTIFIER, metadatum.value, null);
                    this.epub_metadata.addMetadatum(u);
                    got_unique_identifier = true;
                }
            }
        }
        if ((! got_unique_identifier) && (! this.lenient_parsing)) {
            throw new RB.Exception(this.exception_tag, "Cannot get EPUB unique-identifier from '" + this.opf_file_path + "'");
        }
    
    } else {
        throw new RB.Exception(this.exception_tag, "Cannot parse OPF file '" + this.opf_file_path + "'");
    }
};
/**
    parse OPF metadata
    @private
*/
RB.Format.EPUB.EPUB.prototype.parseOPFMetadata = function(el) {
    // parse DC elements
    var dc_elements = [
        RB.Format.OPF.Metadatum.NameEnum.DC_CONTRIBUTOR,
        RB.Format.OPF.Metadatum.NameEnum.DC_COVERAGE,
        RB.Format.OPF.Metadatum.NameEnum.DC_CREATOR,
        RB.Format.OPF.Metadatum.NameEnum.DC_DATE,
        RB.Format.OPF.Metadatum.NameEnum.DC_DESCRIPTION,
        RB.Format.OPF.Metadatum.NameEnum.DC_FORMAT,
        RB.Format.OPF.Metadatum.NameEnum.DC_IDENTIFIER,
        RB.Format.OPF.Metadatum.NameEnum.DC_LANGUAGE,
        RB.Format.OPF.Metadatum.NameEnum.DC_PUBLISHER,
        RB.Format.OPF.Metadatum.NameEnum.DC_RELATION,
        RB.Format.OPF.Metadatum.NameEnum.DC_RIGHTS,
        RB.Format.OPF.Metadatum.NameEnum.DC_SOURCE,
        RB.Format.OPF.Metadatum.NameEnum.DC_SUBJECT,
        RB.Format.OPF.Metadatum.NameEnum.DC_TITLE,
        RB.Format.OPF.Metadatum.NameEnum.DC_TYPE
    ];
    for (var i = 0; i < dc_elements.length; i++) {
        var dc_element = dc_elements[i];
        var arr = RB.Utilities.getElementValue(el, dc_element.replace("dc:", ""), "http://purl.org/dc/elements/1.1/", []);
        for (var j = 0; j < arr.length; j++) {
            var m = arr[j];
            var v = new RB.Format.OPF.Metadatum(m.id, dc_element, m.value, m.attributes);
            this.epub_metadata.addMetadatum(v);
        }
    }

    // parse meta elements
    // TODO put these into an appropriate namespace.enumeration?
    var meta_attributes = [
        'content',
        'name',
        'property',
        'refines',
        'role',
        'scheme',
    ];
   
    // values for meta property
    // TODO put these into an appropriate namespace.enumeration?
    var meta_property_values = [
        'alternate-script',
        'belongs-to-collection',
        'collection-type',
        'display-seq',
        'file-as',
        'group-position',
        'identifier-type',
        'meta-auth',
        'role',
        'source-of',
        'title-type'
    ];

    // single valued properties: `<meta property="...">...</meta>`
    var single_valued_properties = [
        RB.Format.OPF.Metadatum.NameEnum.DCTERMS_MODIFIED,
        RB.Format.OPF.Metadatum.NameEnum.MEDIA_ACTIVE_CLASS,
        RB.Format.OPF.Metadatum.NameEnum.MEDIA_NARRATOR,
        RB.Format.OPF.Metadatum.NameEnum.MEDIA_PAUSED_CLASS,
        RB.Format.OPF.Metadatum.NameEnum.MEDIA_PLAYBACK_ACTIVE_CLASS,
        RB.Format.OPF.Metadatum.NameEnum.PARALLEL_LANGUAGE,
        RB.Format.OPF.Metadatum.NameEnum.PARALLEL_LINK_CLASS,
        RB.Format.OPF.Metadatum.NameEnum.PARALLEL_TEXT_CLASS,
        RB.Format.OPF.Metadatum.NameEnum.RENDITION_FLOW,
        RB.Format.OPF.Metadatum.NameEnum.RENDITION_LAYOUT,
        RB.Format.OPF.Metadatum.NameEnum.RENDITION_ORIENTATION,
        RB.Format.OPF.Metadatum.NameEnum.RENDITION_SPREAD,
        RB.Format.OPF.Metadatum.NameEnum.RENDITION_VIEWPORT
    ];
  
    var meta_elements = RB.Utilities.getElementValue(el, "meta", null, meta_attributes);
    for (var i = 0; i < meta_elements.length; i++) {
        var meta_element = meta_elements[i];
        var meta_attributes = meta_element["attributes"];
        var meta_value = meta_element["value"];

        // EPUB 2-style metas
        if ("name" in meta_attributes) {
            // EPUB 2-style cover: `<meta name="cover" content="cover_id_as_in_manifest_id" />`
            if (meta_attributes["name"] === "cover") {
                var v = new RB.Format.OPF.Metadatum(meta_element.id, RB.Format.OPF.Metadatum.NameEnum.EPUB2_COVER, meta_attributes["content"], null);
                this.epub_metadata.addMetadatum(v);
            }

            // do not cross linear="no" spine items: `<meta name="nonlinear:crossable" content="false" />`
            if (meta_attributes["name"] === RB.Format.OPF.Metadatum.NameEnum.NONLINEAR_CROSSABLE) {
                var v = new RB.Format.OPF.Metadatum(meta_element.id, RB.Format.OPF.Metadatum.NameEnum.NONLINEAR_CROSSABLE, meta_attributes["content"], null);
                this.epub_metadata.addMetadatum(v);
            }

        }

        // EPUB 3-style metas
        if ("property" in meta_attributes) {
            var meta_property = meta_attributes["property"];
            // single valued properties
            if (single_valued_properties.indexOf(meta_property) > -1) {
                var v = new RB.Format.OPF.Metadatum(meta_element.id, meta_property, meta_value, meta_attributes);
                this.epub_metadata.addMetadatum(v);
            }

            // TODO: do this AFTER manifest has been parsed?
            // A possible way consists in attaching a "duration" attribute to the corresponding manifest item.
            // media:duration refines
            // `<meta property="media:duration">`...`</meta>`
            // `<meta property="media:duration" refines="#s001">`...`</meta>`            
            if (meta_property === RB.Format.OPF.Metadatum.NameEnum.MEDIA_DURATION) {
                var refines = meta_attributes["refines"];
                if (refines) {
                    // refines the duration of a Media Overlay
                    // removes '#'
                    refines = refines.replace("#", "");
                    var v = new RB.Format.OPF.Metadatum(meta_element.id, RB.Format.OPF.Metadatum.NameEnum.MEDIA_DURATION + "#" + refines, meta_value, null);
                    this.epub_metadata.addMetadatum(v);
                } else {
                    // global (i.e., total)
                    var v = new RB.Format.OPF.Metadatum(meta_element.id, RB.Format.OPF.Metadatum.NameEnum.MEDIA_DURATION_TOTAL, meta_value, null);
                    this.epub_metadata.addMetadatum(v);
                }
            }

            // TODO: as in the above
            // rendition:viewport refines
            // `<meta property="rendition:viewport">`...`</meta>`
            // `<meta property="rendition:viewport" refines="#p001">`...`</meta>`
            if (meta_property === RB.Format.OPF.Metadatum.NameEnum.RENDITION_VIEWPORT) {
                var refines = meta_attributes["refines"];
                if (refines) {
                    // refines the viewport information for a spine item
                    // removes '#'
                    refines = refines.replace("#", "");
                    var v = new RB.Format.OPF.Metadatum(meta_element.id, RB.Format.OPF.Metadatum.NameEnum.RENDITION_VIEWPORT + "#" + refines, meta_value, null);
                    this.epub_metadata.addMetadatum(v);
                } else {
                    // global
                    var v = new RB.Format.OPF.Metadatum(meta_element.id, RB.Format.OPF.Metadatum.NameEnum.RENDITION_VIEWPORT_GLOBAL, meta_value, null);
                    this.epub_metadata.addMetadatum(v);
                }
            }

            // handle refines, i.e.:
            // `<dc:creator id="aut">...</dc:creator>`
            // `<meta refines="#aut" property="role" scheme="marc:relators">...</meta>`
            // `<meta refines="#aut" property="file-as">...</meta>`            
            if (meta_property_values.indexOf(meta_property) > -1) {
                var refines = meta_attributes["refines"];
                if (refines) {
                    // removes '#'
                    refines = refines.replace("#", ""); 
                    var m = this.epub_metadata.getMetadatumById(refines);
                    if (m) {
                        m.appendAttributes({ meta_property: meta_value });
                    }
                }
            }
        }
    }
};
/**
    parse OPF manifest
    @private
*/
RB.Format.EPUB.EPUB.prototype.parseOPFManifest = function(el) {
    var attributes = [
        "href",
        "media-type",
        "fallback",
        "media-overlay",
        "properties",
        "fallback"
    ];

    var arr = RB.Utilities.getElementValue(el, "item", null, attributes);
    for (var i = 0; i < arr.length; i++) {
        var item = arr[i];
        var item_attributes = item["attributes"];
        var item_info = { "fallback": item_attributes["fallback"], "media-overlay": item_attributes["media-overlay"], "properties": item_attributes["properties"]}
        var mi = new RB.Format.OPF.ManifestItem(item["id"], RB.Utilities.normalizePath(this.opf_directory + item_attributes["href"]), item_attributes["media-type"], item_info, null);
        this.epub_manifest.addManifestItem(mi);

        // has media-overlay?
        if (item_attributes["media-overlay"]) {
            this.has_media_overlays = true;
        }

        // is this a NCX TOC?
        if (item_attributes["media-type"] === "application/x-dtbncx+xml") {
            this.ncx_file_path = RB.Utilities.normalizePath(this.opf_directory + item_attributes["href"]);
        }

        // has properties?
        if (item_attributes["properties"]) {

            // is this a cover?
            if (item_attributes["properties"].indexOf("cover-image") > -1) {
                var v = new RB.Format.OPF.Metadatum(null, RB.Format.OPF.Metadatum.NameEnum.EPUB3_COVER, item["id"], null);
                this.epub_metadata.addMetadatum(v);
            }

            // has this MathML?
            if (item_attributes["properties"].indexOf("mathml") > -1) {
                this.has_mathml = true;
            }

            // is this a XHTML (nav) TOC?
            if (item_attributes["properties"].indexOf("nav") > -1) {
                this.nav_file_path = RB.Utilities.normalizePath(this.opf_directory + item_attributes["href"]);
            }
            
            // has this remote-resources?
            if (item_attributes["properties"].indexOf("remote-resources") > -1) {
                this.has_remote_resources = true;
            }
            
            // is this scripted?
            if (item_attributes["properties"].indexOf("scripted") > -1) {
                this.has_scripted = true;
            }
            
            // has this svg?
            if (item_attributes["properties"].indexOf("svg") > -1) {
                this.has_svg = true;
            }
            
            // has this switch?
            if (item_attributes["properties"].indexOf("switch") > -1) {
                this.has_switch = true;
            }            

        }
    }
};
/**
    parse OPF spine
    @private
*/
RB.Format.EPUB.EPUB.prototype.parseOPFSpine = function(el) {
    var ppd = el.getAttribute("page-progression-direction");
    if (ppd) {
        this.epub_spine["page-progression-direction"] = ppd;
    }
    var toc = el.getAttribute("toc");
    if (toc) {
        this.epub_spine["toc"] = toc;
    }
    var attributes = [ "idref", "linear", "properties" ];
    var arr = RB.Utilities.getElementValue(el, "itemref", null, attributes);
    for (var i = 0; i < arr.length; i++) {
        var itemref_attributes = arr[i]["attributes"];
        var si = new RB.Format.OPF.SpineItem(itemref_attributes["idref"], itemref_attributes["linear"], itemref_attributes["properties"]);
        this.epub_spine.addSpineItem(si);
    }
};
/**
    parse OPF guide (optional in EPUB 2, deprecated in EPUB 3)
    @private
*/
RB.Format.EPUB.EPUB.prototype.parseOPFGuide = function(el) {
    var attributes = [ "href", "title", "type" ];
    var guide_values = [ "cover", "text", "toc" ];
    var arr = RB.Utilities.getElementValue(el, "reference", null, attributes);
    for (var i = 0; i < arr.length; i++) {
        var reference_attributes = arr[i]["attributes"];
        if ("type" in reference_attributes) {
            var name = null;
            if (reference_attributes["type"] === "cover") {
                name = RB.Format.OPF.Metadatum.NameEnum.EPUB2_GUIDE_COVER;
            }   
            if (reference_attributes["type"] === "text") {
                name = RB.Format.OPF.Metadatum.NameEnum.EPUB2_GUIDE_TEXT;
            }   
            if (reference_attributes["type"] === "toc") {
                name = RB.Format.OPF.Metadatum.NameEnum.EPUB2_GUIDE_TOC;
            }   

            if (name) {
                var v = new RB.Format.OPF.Metadatum(null, name, RB.Utilities.normalizePath(this.opf_directory + reference_attributes["href"]), null);
                this.epub_metadata.addMetadatum(v);
            }
        }
    }
};
/**
    parse TOC file
    @todo parse EPUB 3 landmarks and other navs (e.g., loa)
    @private
*/
RB.Format.EPUB.EPUB.prototype.parseTOC = function() {
    /*
    // by removing this check on the EPUB version,
    // we are a little bit more lenient
    // as we allow fallback with NCX TOC if XHTML nav TOC is not found
    var version = this.getMetadatumValue(RB.Format.OPF.Metadatum.NameEnum.EPUB_VERSION, true, true);
    if (!version) {
        return;
    }
    if ((version.substring(0, 1) === "3") && (this.nav_file_path)) {
        // parse XHTML nav TOC
    }
    if ((version.substring(0, 1) === "2") && (this.ncx_file_path)) {
        // parse NCX TOC
    }
    */
    if (this.nav_file_path) {
        // there is a XHTML nav TOC, try parsing it 
        var nav_file_content = RB.Utilities.loadXMLFile(this.unpacked_directory + this.nav_file_path);
        if (nav_file_content) {
            var navs = nav_file_content.getElementsByTagNameNS("*", "nav");
            // sentinel: allows us to parse other navs, e.g. landmarks or loa
            var toc_found = false;
            for (var i = 0; i < navs.length; i++) {
                var nav_type = navs[i].getAttribute("epub:type");
                if (nav_type) {
                    if (nav_type === "toc") {
                        // nav TOC found!
                        // ignore optional h1-h6 headings
                        // get first ol
                        var ol = navs[i].getElementsByTagNameNS("*", "ol");
                        if ((ol) && (ol.length > 0)) {
                            var c = this.parseTOCOL(ol[0]);
                            for (var j = 0; j < c.length; j++) {
                                this.epub_toc.addTOCItem(c[j]);
                            }
                            this.epub_toc.computeTOCItemByHref();
                            // TOC found: set sentinel
                            toc_found = true;
                        }
                    }
                    /* TODO
                    if (nav_type === "landmarks") {
                    }
                    if (nav_type === "loa") {
                    }
                    */
                }
            }
            if (toc_found) {
                // success: return
                return;
            }
        }
    }

    // if here, either we have an EPUB 2 or we failed to parse XHTML nav TOC
    if (this.ncx_file_path) {
        // there is a NCX TOC, try parsing it
        var ncx_file_content = RB.Utilities.loadXMLFile(this.unpacked_directory + this.ncx_file_path);
        if (ncx_file_content) {
            var navMap = ncx_file_content.getElementsByTagNameNS("http://www.daisy.org/z3986/2005/ncx/", "navMap");
            if ((navMap) && (navMap.length > 0)) {
                var navPoints = navMap[0].childNodes;
                var c = this.parseNavPoints(navPoints);
                for (var i = 0; i < c.length; i++) {
                    this.epub_toc.addTOCItem(c[i]);
                }
                this.epub_toc.computeTOCItemByHref();
            }
        }
    }
};
/**
    parse TOC OL element
    @private
*/
RB.Format.EPUB.EPUB.prototype.parseTOCOL = function(el) {
    var children = [];
    if (el) {
        var nav_file_directory = RB.Utilities.getParentDirectory(this.nav_file_path);
        var lis = el.childNodes;
        for (var i = 0; i < lis.length; i++) {
            if (lis[i].nodeName === "li") {
                // specs say only one a, span, or ol is allowed here
                var a = lis[i].getElementsByTagNameNS("*", "a")[0];
                var span = lis[i].getElementsByTagNameNS("*", "span")[0];
                var ol = lis[i].getElementsByTagNameNS("*", "ol")[0];
                var item_label = null;
                var item_href = null;
                var item_children = null;
                var item_anchor = null;
                if (a) {
                    // TODO better removal of HTML markup?
                    item_label = a.innerHTML.replace(/<[^>]*>/g, '');
                    var tmp = RB.Utilities.splitHref(a.getAttribute("href"));
                    item_href = RB.Utilities.normalizePath(nav_file_directory + tmp[0]);
                    item_anchor = tmp[1];
                }
                if (span) {
                    item_label = a.innerHTML;
                }
                if (ol) {
                    item_children = this.parseTOCOL(ol);
                }
                var n = new RB.Format.TOC.TOCItem(item_href, item_anchor, item_label, item_children);
                children.push(n);
            }
        }
    }
    return children;
}; 
/**
    parse a TOC array of NavPoint elements
    @private
*/
RB.Format.EPUB.EPUB.prototype.parseNavPoints = function(navPoints) {
    var children = [];
    if ((navPoints) && (navPoints.length > 0)) {
        var ncx_file_directory = RB.Utilities.getParentDirectory(this.ncx_file_path);
        for (var i = 0; i < navPoints.length; i++) {
            var el = navPoints[i];
            if (el.nodeName.indexOf("navPoint") > -1) {
                var el_text = null;
                var el_content = null;
                var item_label = null;
                var item_href = null;
                var item_children = null;
                var item_anchor = null;
                for (var j = 0; j < el.childNodes.length; j++) {
                    var child = el.childNodes[j];
                    if (child.nodeName.indexOf("navLabel") > -1) {
                        var labels = child.getElementsByTagNameNS("*", "text");
                        if ((labels) && (labels.length > 0)) {
                            el_text = labels[0];
                        }
                    }
                    if (child.nodeName.indexOf("content") > -1) {
                        el_content = child;
                    }
                }
                if ((el_text) && (el_text.textContent)) {
                    // TODO better removal of HTML markup?
                    item_label = el_text.textContent.replace(/<[^>]*>/g, '');
                }
                if (el_content) {
                    var tmp = RB.Utilities.splitHref(el_content.getAttribute("src"));
                    item_href = RB.Utilities.normalizePath(ncx_file_directory + tmp[0]);
                    item_anchor = tmp[1];
                }
                if ((el.childNodes) && (el.childNodes.length > 0)) {
                    item_children = this.parseNavPoints(el.childNodes);
                }
                var n = new RB.Format.TOC.TOCItem(item_href, item_anchor, item_label, item_children);
                children.push(n);
            }
        }
    }
    return children;
};
/**
    build playlist from metadata, manifest, and TOC
    @private
*/
RB.Format.EPUB.EPUB.prototype.buildPlaylist = function() {
    var spine = this.epub_spine.spine;
    for (var i = 0; i < spine.length; i++) {
        var s = spine[i];
        if (s.idref) {
            var manifestItem = this.epub_manifest.getManifestItemById(s.idref);
            if ((manifestItem) && (manifestItem["media-overlay"])) {
                var p_id       = manifestItem["media-overlay"];
                var p_href     = manifestItem.href;
                var p_label    = null;
                var p_duration = "00:00";
                var p_tocItem  = this.epub_toc.getTOCItemByHref(p_href);
                if ((p_tocItem) && (p_tocItem.label)) {
                    p_label = p_tocItem.label;
                }
                var p_metaItem = this.epub_metadata.getMetadatumValue(RB.Format.OPF.Metadatum.NameEnum.MEDIA_DURATION + "#" + p_id, true, true);
                if (p_metaItem) {
                    var seconds = RB.Utilities.clockValueToSeconds(p_metaItem);
                    p_duration = RB.Utilities.prettifyClockValue(seconds, true);
                }
                var p = new RB.Format.Playlist.PlaylistItem(p_href, p_label, p_duration);
                this.epub_playlist.addPlaylistItem(p);
            }
        }
    } 
};
/**
    build ROD (reading order data) structure, from metadata, manifest, spine, and by parsing MO
    @private
*/
RB.Format.EPUB.EPUB.prototype.buildROD = function() {
    var global_rendition_values                      = {};
    global_rendition_values["rendition:flow"]        = this.epub_metadata.getMetadatumValue(RB.Format.OPF.Metadatum.NameEnum.RENDITION_FLOW, true, true); 
    global_rendition_values["rendition:layout"]      = this.epub_metadata.getMetadatumValue(RB.Format.OPF.Metadatum.NameEnum.RENDITION_LAYOUT, true, true); 
    global_rendition_values["rendition:orientation"] = this.epub_metadata.getMetadatumValue(RB.Format.OPF.Metadatum.NameEnum.RENDITION_ORIENTATION, true, true); 
    global_rendition_values["rendition:spread"]      = this.epub_metadata.getMetadatumValue(RB.Format.OPF.Metadatum.NameEnum.RENDITION_SPREAD, true, true); 
    global_rendition_values["rendition:viewport"]    = RB.Utilities.parseViewportString(this.epub_metadata.getMetadatumValue(RB.Format.OPF.Metadatum.NameEnum.RENDITION_VIEWPORT_GLOBAL, true, true));
    
    var spine = this.epub_spine.spine;
    for (var i = 0; i < spine.length; i++) {
        var s = spine[i];
        if (s.idref) {
            var manifestItem = this.epub_manifest.getManifestItemById(s.idref);
            if (manifestItem) {
                var r_id             = manifestItem.id;
                var r_text_src       = manifestItem.href;
                var r_mo_manifest_id = manifestItem["media-overlay"];
                var r_info           = {};
                
                // set linear attribute
                r_info["linear"]     = (s.linear !== "no");
               
                // parse rendition properties
                r_info["rendition"]  = this.parseRenditionProperitesOfRODItem(r_id, s.properties, global_rendition_values);

                // create RODItem
                var n = new RB.Format.ROD.RODItem(r_id, r_text_src, r_info);

                // parse MO if needed
                if ((r_mo_manifest_id) && (!this.incremental_mo_parsing)) {
                    this.parseMediaOverlaysOfRODItem(n, manifestItem);
                }

                // add RODItem
                this.epub_rod.addRODItem(n);
            }
        }
    }
};
/**
    parse the rendition properties associated with a ROD
    @private
*/
RB.Format.EPUB.EPUB.prototype.parseRenditionProperitesOfRODItem = function(manifestItemID, properties, globalRenditionValues) {
    // TODO refactor this
    var toBeReturned = {};
    
    // flow
    toBeReturned["rendition:flow"] = globalRenditionValues["rendition:flow"];
    if (properties) {
        var overrides = [
            [RB.Format.OPF.SpineItem.PropertiesEnum.RENDITION_FLOW_AUTO,                RB.Format.EPUB.RenditionFlowEnum.AUTO],
            [RB.Format.OPF.SpineItem.PropertiesEnum.RENDITION_FLOW_PAGINATED,           RB.Format.EPUB.RenditionFlowEnum.PAGINATED],
            [RB.Format.OPF.SpineItem.PropertiesEnum.RENDITION_FLOW_SCROLLED_CONTINUOUS, RB.Format.EPUB.RenditionFlowEnum.SCROLLED_CONTINUOUS],
            [RB.Format.OPF.SpineItem.PropertiesEnum.RENDITION_FLOW_SCROLLED_DOC,        RB.Format.EPUB.RenditionFlowEnum.SCROLLED_DOC]
        ];
        for (var i = 0; i < overrides.length; i++) {
            if (properties.indexOf(overrides[i][0]) > -1) {
                toBeReturned["rendition:flow"] = overrides[i][1];
            }
        }
    }
    if (! toBeReturned["rendition:flow"]) {
        // defaults to auto
        toBeReturned["rendition:flow"] = RB.Format.EPUB.RenditionFlowEnum.AUTO;
    }

    // align-x-center (spine item only)
    toBeReturned["rendition:align-x-center"] = null;
    if (properties) {
        var overrides = [
            [RB.Format.OPF.SpineItem.PropertiesEnum.RENDITION_ALIGN_X_CENTER, RB.Format.OPF.SpineItem.PropertiesEnum.RENDITION_ALIGN_X_CENTER],
        ];
        for (var i = 0; i < overrides.length; i++) {
            if (properties.indexOf(overrides[i][0]) > -1) {
                toBeReturned["rendition:align-x-center"] = overrides[i][1];
            }
        }
    }

    // layout
    toBeReturned["rendition:layout"] = globalRenditionValues["rendition:layout"];
    if (properties) {
        var overrides = [
            [RB.Format.OPF.SpineItem.PropertiesEnum.RENDITION_LAYOUT_REFLOWABLE,    RB.Format.EPUB.RenditionLayoutEnum.REFLOWABLE],
            [RB.Format.OPF.SpineItem.PropertiesEnum.RENDITION_LAYOUT_PRE_PAGINATED, RB.Format.EPUB.RenditionLayoutEnum.PRE_PAGINATED]
        ];
        for (var i = 0; i < overrides.length; i++) {
            if (properties.indexOf(overrides[i][0]) > -1) {
                toBeReturned["rendition:layout"] = overrides[i][1];
            }
        }
    }
    if (! toBeReturned["rendition:layout"]) {
        // defaults to reflowable
        toBeReturned["rendition:layout"] = RB.Format.EPUB.RenditionLayoutEnum.REFLOWABLE;
    }

    // orientation
    toBeReturned["rendition:orientation"] = globalRenditionValues["rendition:orientation"];
    if (properties) {
        var overrides = [
            [RB.Format.OPF.SpineItem.PropertiesEnum.RENDITION_ORIENTATION_LANDSCAPE, RB.Format.EPUB.RenditionOrientationEnum.LANDSCAPE],
            [RB.Format.OPF.SpineItem.PropertiesEnum.RENDITION_ORIENTATION_PORTRAIT,  RB.Format.EPUB.RenditionOrientationEnum.PORTRAIT],
            [RB.Format.OPF.SpineItem.PropertiesEnum.RENDITION_ORIENTATION_AUTO,      RB.Format.EPUB.RenditionOrientationEnum.AUTO]
        ];
        for (var i = 0; i < overrides.length; i++) {
            if (properties.indexOf(overrides[i][0]) > -1) {
                toBeReturned["rendition:orientation"] = overrides[i][1];
            }
        }
    }
    if (! toBeReturned["rendition:orientation"]) {
        // defaults to auto 
        toBeReturned["rendition:orientation"] = RB.Format.EPUB.RenditionOrientationEnum.AUTO;
    }

    // spread
    toBeReturned["rendition:spread"] = globalRenditionValues["rendition:spread"];
    if (properties) {
        var overrides = [
            [RB.Format.OPF.SpineItem.PropertiesEnum.RENDITION_SPREAD_NONE,      RB.Format.EPUB.RenditionSpreadEnum.NONE],
            [RB.Format.OPF.SpineItem.PropertiesEnum.RENDITION_SPREAD_LANDSCAPE, RB.Format.EPUB.RenditionSpreadEnum.LANDSCAPE],
            [RB.Format.OPF.SpineItem.PropertiesEnum.RENDITION_SPREAD_PORTRAIT,  RB.Format.EPUB.RenditionSpreadEnum.PORTRAIT],
            [RB.Format.OPF.SpineItem.PropertiesEnum.RENDITION_SPREAD_BOTH,      RB.Format.EPUB.RenditionSpreadEnum.BOTH],
            [RB.Format.OPF.SpineItem.PropertiesEnum.RENDITION_SPREAD_AUTO,      RB.Format.EPUB.RenditionSpreadEnum.AUTO]
        ];
        for (var i = 0; i < overrides.length; i++) {
            if (properties.indexOf(overrides[i][0]) > -1) {
                toBeReturned["rendition:spread"] = overrides[i][1];
            }
        }
    }
    if (! toBeReturned["rendition:spread"]) {
        // defaults to auto 
        toBeReturned["rendition:spread"] = RB.Format.EPUB.RenditionSpreadEnum.AUTO;
    }

    // page spread (spine item only)
    toBeReturned["page-spread"] = null;
    if (properties) {
        var overrides = [
            [RB.Format.OPF.SpineItem.PropertiesEnum.RENDITION_PAGE_SPREAD_CENTER, RB.Format.OPF.SpineItem.PropertiesEnum.RENDITION_PAGE_SPREAD_CENTER],
            [RB.Format.OPF.SpineItem.PropertiesEnum.PAGE_SPREAD_LEFT,             RB.Format.OPF.SpineItem.PropertiesEnum.PAGE_SPREAD_LEFT],
            [RB.Format.OPF.SpineItem.PropertiesEnum.PAGE_SPREAD_RIGHT,            RB.Format.OPF.SpineItem.PropertiesEnum.PAGE_SPREAD_RIGHT],
        ];
        for (var i = 0; i < overrides.length; i++) {
            if (properties.indexOf(overrides[i][0]) > -1) {
                toBeReturned["page-spread"] = overrides[i][1];
            }
        }
    }

    // viewport
    if (toBeReturned["rendition:layout"] === RB.Format.EPUB.RenditionLayoutEnum.PRE_PAGINATED) {
        // viewport should be read only if PRE_PAGINATED
        toBeReturned["rendition:viewport"] = globalRenditionValues["rendition:viewport"];
        var override_viewport = RB.Utilities.parseViewportString(this.epub_metadata.getMetadatumValue(RB.Format.OPF.Metadatum.NameEnum.RENDITION_VIEWPORT + "#" + manifestItemID, true, true));
        if (override_viewport) {
            toBeReturned["rendition:viewport"] = override_viewport;
        }
    } else {
        // ignore viewport info when REFLOWABLE
        toBeReturned["rendition:viewport"] = null;
    }

    return toBeReturned; 
};
/**
    parse the Media Overlay (SMIL) file associated with a ROD
    (useful when `this.incremental_mo_parsing` is `true`)
    @private
*/
RB.Format.EPUB.EPUB.prototype.parseMediaOverlaysOfRODItem = function(rodItem, manifestItem) {
    var manifestItem = manifestItem || this.epub_manifest.getManifestItemById(rodItem.id);
    if (manifestItem) {
        var r_text_src       = manifestItem.href;
        var r_audio_src      = null;
        var r_duration       = null;
        var r_smil_data      = null;
        var r_valid_mo       = null;
        var r_mo_manifest_id = manifestItem["media-overlay"];
                    
        if (r_mo_manifest_id) {
            // parse the associated Media Overlay (SMIL) file
            var tmp = this.parseSMILFile(r_mo_manifest_id, r_text_src);
            r_valid_mo  = tmp[0];
            r_audio_src = tmp[1];
            r_smil_data = tmp[2];

            // get duration
            var p_metaItem = this.epub_metadata.getMetadatumValue(RB.Format.OPF.Metadatum.NameEnum.MEDIA_DURATION + "#" + r_mo_manifest_id, true, true);
            if (p_metaItem) {
                r_duration = RB.Utilities.clockValueToSeconds(p_metaItem);
            }
            
            // store
            rodItem.audio_src = r_audio_src;
            rodItem.duration  = r_duration;
            rodItem.valid_mo  = r_valid_mo;
            if ((r_valid_mo) && (r_smil_data)) {
                for (var j = 0; j < r_smil_data.length; j++) {
                    rodItem.addSMILFragment(r_smil_data[j]);
                }
            }
        }
    }
};
/**
    Parse a SMIL file, keeping only the `<par>` children whose text src is r_text_src.
    Currently, only SMIL files with <par> elements
    having both the <text> and <audio> children are supported.
    In other words, embedded media (i.e., no <text> child) are not supported.
    Moreover, escapability/skippability (i.e., managing epub:type attributes)
    are not supported.

    @todo support generic structure of SMIL files
    @private
    @returns [ valid_mo, audio_src, smil_data ]
*/
RB.Format.EPUB.EPUB.prototype.parseSMILFile = function(manifest_id, r_text_src) {
    var manifestItem = this.epub_manifest.getManifestItemById(manifest_id);
    if ((manifestItem) && (manifestItem.href)) {
        var smil_file_directory = RB.Utilities.getParentDirectory(manifestItem.href);
        var smil_file_content   = RB.Utilities.loadXMLFile(this.unpacked_directory + manifestItem.href);
        if (smil_file_content) {
            
            // get body
            var smil_body = smil_file_content.getElementsByTagNameNS("*", "body");
            if (smil_body.length === 1) {
                // to be returned
                var valid_mo           = true;
                var audio_src          = [];
                var processed_pars     = 0;
                var smil_data          = null;
                var text_src_resolved  = {};
                var audio_src_resolved = {};

                // check if linear (or linearizable) mo
                var previous_clip_end  = null;
                var previous_audio_src = null;

                // get <par> elements, possibly ignoring nested <seq>
                var pars = smil_body[0].getElementsByTagNameNS("*", "par");
                if (pars.length > 0) {
                    smil_data = [];
                    for (var i = 0; i < pars.length; i++) {
                        var f_text_src         = null;
                        var f_text_src_anchor  = null;
                        
                        var f_audio_src        = null;
                        var f_audio_clipBegin  = null;
                        var f_audio_clipEnd    = null;
                        
                        // get text src and text src anchor
                        var text = pars[i].getElementsByTagNameNS("*", "text");
                        if (text.length === 1) {
                            var f_text        = RB.Utilities.splitHref(text[0].getAttribute('src'));
                            f_text_src        = f_text[0];
                            f_text_src_anchor = f_text[1];
                            
                            // resolve text src
                            var f_text_src_resolved = text_src_resolved[f_text_src];
                            if (! f_text_src_resolved) {
                                f_text_src_resolved = RB.Utilities.normalizePath(smil_file_directory + f_text_src);
                                text_src_resolved[f_text_src] = f_text_src_resolved;
                            }
                            f_text_src = f_text_src_resolved;

                            if (f_text_src === r_text_src) {
                                // process this <par> since it has the required text src

                                var audio = pars[i].getElementsByTagNameNS("*", "audio");
                                if (audio.length === 1) {
                                    var f_audio = audio[0];
                                    f_audio_src = f_audio.getAttribute('src');

                                    // get audio src (resolved)
                                    var f_audio_src_resolved = audio_src_resolved[f_audio_src];
                                    if (! f_audio_src_resolved) {
                                        f_audio_src_resolved = RB.Utilities.normalizePath(smil_file_directory + f_audio_src);
                                        audio_src_resolved[f_audio_src] = f_audio_src_resolved;
                                        // add to audio_src
                                        audio_src.push(f_audio_src_resolved);
                                    }
                                    f_audio_src = f_audio_src_resolved;

                                    // get clipBegin
                                    f_audio_clipBegin = f_audio.getAttribute("clipBegin");
                                    if (f_audio_clipBegin === null) {
                                        // mo-audio-010 (clipBegin not specified)
                                        // => set to 0
                                        f_audio_clipBegin = 0;
                                    } else {
                                        f_audio_clipBegin = RB.Utilities.clockValueToSeconds(f_audio_clipBegin);
                                    }

                                    // get clipEnd
                                    f_audio_clipEnd = f_audio.getAttribute("clipEnd");
                                    if (f_audio_clipEnd === null) {
                                        // mo-audio-020 (clipEnd not specified)
                                        // => pass -1, meaning "play until the end of the audio file";
                                        //    the actual clipEnd (equal to the duration of physical media)
                                        //    should be set by the app after inspecting the duration of physical media
                                        f_audio_clipEnd = -1;
                                    } else {
                                        f_audio_clipEnd = RB.Utilities.clockValueToSeconds(f_audio_clipEnd);
                                    }

                                    /*
                                    //
                                    // 2014-01-12 removed this limitation
                                    //
                                    // check if this is a valid MO according to:
                                    //
                                    // if (audio_src(i+1) === audio_src(i)) then clipBegin(i+1) === clipEnd(i)
                                    //
                                    if ((previous_audio_src !== null) && (previous_audio_src === f_audio_src) && (previous_clip_end !== null) && (f_audio_clipBegin !== previous_clip_end)) {
                                        // not supported!!!
                                        //alert("ERROR: " + previous_clip_end + " " + f_audio_clipBegin + " " + r_text_src);
                                        valid_mo = false;
                                        break;
                                    }
                                    */
                                    
                                    previous_audio_src = f_audio_src;
                                    previous_clip_end  = f_audio_clipEnd;

                                    // push data
                                    processed_pars += 1;
                                    smil_data.push(new RB.Format.SMIL.SMILFragment(f_text_src, f_text_src_anchor, f_audio_src, f_audio_clipBegin, f_audio_clipEnd));

                                } else {
                                    // audio.length !== 1 => malformed!!!
                                    //alert("ERROR: audio.length !== 1 " + r_text_src);
                                    valid_mo = false;
                                    break;
                                }

                            } else {
                                // ignore this <par>, because it has a text src different than the requested one
                                // alert("ignoring this par! " + f_text_src);
                            }
                        } else {
                            // text.length !== 1 => malformed!!!
                            //alert("ERROR: text.length !== 1 " + r_text_src);
                            valid_mo = false;
                            break;
                        }
                    
                    } // end for

                    // return correct audio_src path
                    if ((processed_pars > 0) && (valid_mo) && (audio_src)) {
                        return [ valid_mo, audio_src, smil_data ];
                    }
                    
                    //alert("ERROR: after return " + r_text_src);

                } // end pars.length > 0
               
            } // end smil_body.length === 1
        
        } // end smil_file_content
    
    } // end manifestItem
    
    // NON FATAL, just signal that this SMIL file is not supported
    return [ false, null, null ];
};



